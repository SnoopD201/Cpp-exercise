# C++基础知识整理归纳

## 1.C++初步知识

低级语言：机器或汇编语言

1954年出现高级语言FORTRAN，之后出现C(1972年有贝尔实验室的D.M.Ritchie发明)和BASIC(1964年在FORTRAN语言的基础上简化而来)，1980年贝尔实验室的Bjarne Stroustrup发明C++。

C语言：是结构化和模块化的语言，是基于过程的。容易处理较小规模的程序，但当问题比较复杂，程序规模较大时，结构话语言就显得不足。

C++：(1).在基于过程的机制基础上，对C语言做了不少扩充。 (2).增加了面向对象的机制

C++的特点：

>1. 类可以体现数据的封装性和信息屏蔽

C++的实现过程：

>1. 用C++语言编写程序，生成.cpp文件
>2. 编译:用编译器(complier)把原程序翻译成二进制的目标程序，生成.obj文件
>3. 连接：用系统提供的连接程序(linker)将所有的目标文件和系统的库函数以及系统提供的某些其他信息连接起来，生成可执行文件.exe
>4. 运行程序：运动最终形成的可执行的二进制文件(.exe)，得到运行结果



### 最简单的C++程序

```c++
#include <iostream>   //预处理指令,在程序进行编译时，将先对所有的预处理指令进行处理，将头文件的具体内容插入到include处
using namespace std;  //使用命名空间std,C++标准库中的类和函数是在命名空间std中声明的
int main()            //一个c++程序总是从main函数开始执行，若程序不能正常执行，向系统返回一个非零值(一般是-1)
{
    int a;
    cin>>a;
    cout<<a;
    return 0;
}
```

### 头文件

头文件是源文件之间的接口。利用#include指令，可以把不同的文件组合在一起，形成一个文件，避免重复编写代码，提高了编程效率。

头文件(.h)一般包含以下几类：

* 对类型的声明：对结构体或类的声明(而真正的定义放在源文件中)
* 函数声明：为方便用户，可以将同一类的函数声明集中在一个头文件中(如cmath集中了各类数学函数的原型声明)。而函数的定义不是放在头文件中，而是放在函数库或单独编译成目标文件，在编译阶段与用户文件连接组成可执行文件。
* 内置函数的定义：直接定义不要再声明了
* 宏定义：用define定义的符号常量和用const声明的常变量
* 全局变量声明
* 外部变量声明:如extern int a;
* 根据需要可以包含其他头文件

## 2.数据类型与表达式

### c++的数据类型

> 基本类型
>
> > 整形
> >
> > > 短整型(short int 或short)
> > >
> > > 整形(int)
> > >
> > > 长整型(long int 或long)：数字末尾加L或者l表示长整型，前面加0表示8进制，前面加0x表示16进制
> > >
> > > 整型数据之间的赋值：
> > > 按存储单元中的存储形式直接传送。如short int类型的-1以补码形式储存为1111111111111111，赋值给unsigned int则变成了65535.
> > > 将整型赋值给char型，只将其低8位原封不动的送给char型变量.
> > >
> > > 补码：
> > > 在计算机中，数值的存储一律用补码，因为补码可以将符号位与数值域统一处理，加法和减法也可以统一处理。
> > > 符号位:0表示正数，1表示负数
> > > 原码求补码:正数与原码相同，负数将原码除符号位取反再加1，0的补码表示是唯一的00000000.
> >
> > 字符型(char)
> >
> > > 普通字符常量：用单撇号括起来。字符常量使用ASCII码存储的，可以与整数进行混合运算。A对应的ASCII码为65，a对应97。
> > >
> > > 转义字符：'\n'等。 
> > >
> > > 字符串常量：用双撇号括起来，在计算机中存储时会在末尾加一个\0，多占一个字节
> > >
> > > ```c++
> > > 从左到右看,如"I say \"thanks\"\n"为I say "thanks"然后换行
> > > ```
> >
> > 浮点型：可以写成十进制小数形式或者指数形式，但在内存中都是以指数形式(即浮点形式)进行存储，符号在前面，小数部分在中间，指数部分在后面。在存储单元中小数部分和指数部分都是用二进制表示的，不能无限精确。
> >
> > > 单精度型(float)：6为有效数字，4个字节
> > >
> > > 双精度型(double)：15位有效数字，8个字节
> > >
> > > 长双精度型(long double)
> >
> > 布尔型(bool)
> >
> > > false=0,true=1.布尔型可以与数值型数据进行混合运算，true当成1,false当成0，cout<<true为输出1.
>
> 空类型(void)
>
> 派生类型
>
> > 指针类型(*)
> >
> > 数组类型([])
> >
> > 类类型(class)
> >
> > 共用体类型(union)
> >
> > 枚举类型(enum)
> >
> > 结构体类型(struct)
> >
>

### 符号常量

为方便编程和阅读，用一个标识符代表一个字符串常量，在预编译时把所有的符号常量换成所指定的字符串。如：

```c++
#define 宏名 字符串
#define uchar unsigned char  //自己定义的符号放中间
```

特点是含义清楚，可以做到“见名知意”，一个在修改一个常量时可以“一改全改”

#### 符号常量与const常变量的区别：

在定义常变量时必须同时对它初始化(即指定其值)，此后不能再对其赋值。const int a=3;

符号常量只是用一个符号代表一个字符串，在编译时把所有符号常量替换为指定的字符串，它没有类型，没有名字，在内存中并不存在以符号常量命名的存储单元。而常变量是一个变量，有名字，在存储中有以它命名的存储单元，可以用sizeof测出其长度，只是其值不能修改。且常变量可以是字符或数值型，符号常量只代表一个字符串。

### 变量

变量有三个属性，存储类别，作用域，存储期

#### 作用域

##### 局部变量

local variable.在一个函数或复合语句内部定义的变量是内部变量，它只在本函数或本复合语句在有效，在外部无效。在main函数在定义的变量也不可以在其他函数中使用。

##### 全局变量

global variable.在函数之外定义的变量为全局变量，其有效范围从定义变量的位置开始到源文件结束。如在main函数上面定义的全局变量可以在所有函数中使用,且在其他函数中不需要再定义一次。如在同一个源文件中，全局变量和局部变量重名，则全局变量被屏蔽。

建议不在必要时不使用全局变量，因为全局变量在程序全部执行过程中都占用存储单元，且它使函数的通用性降低了。
在程序设计时，在划分模块时要求模块的内聚性强，耦合性弱。即模块的功能要单一，与其他模块的相互影响要尽量少。这样程序移植性好，可读性强。

#### 存储类别

内存分为程序区，静态存储区和动态存储区。存储方法有动态存储和静态存储，全局变量放在静态存储区，函数的形式参数、局部变量和函数调用时的现场保护和返回地址等放在动态存储区。

##### 自动变量(auto)

函数中的局部变量，如果不加static声明,就是自动变量，可以加aotu修饰，也可以不加，属于动态存储方式。

##### 用static声明静态局部变量

在函数调用结束后不消失而保留原值。属于静态存储方式。
对静态局部变量是在编译时赋初值的，即只赋值一次。

##### 用register声明寄存器变量

对于使用频繁的变量，不存放在内存中，而直接存储在寄存器中。在函数调用结束后并不保留原值。

##### 用extern声明外部变量

###### 在一个文件内声明全局变量

在一个函数内用extern对变量做外部变量声明，可以提前引用。

###### 在多个文件中声明外部变量

在一个文件内定义int a=3, 在另一个文件中做外部变量声明 extern int a,从而扩展其作用域。不能在多个文件中重复定义外部变量。

##### 用static声明静态外部变量

对外部变量加上static声明,则该外部变量无法被其他文件引用。

### c++运算符与表达式

<img src="D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\运算符和结合性1.png" alt="运算符和结合性1" style="zoom:67%;" />

![运算符和结合性2](D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\运算符和结合性2.png)

![运算符和结合性3](D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\运算符和结合性3.png)

#### 逗号运算符与逗号表达式

x=表达式1，表达式2  //先求解表达式1，再求解表达式2，整个表达式的值就是表达式2的值

```c++
a=5;
a=2*3,4*a;  //a=2*3是表达式1，先得到a=6，然后计算表达式为24,所以整个表达式的值为24.但是a仍为6,因为表达式2没有重新对a进行赋值
```

#### 条件运算符与条件表达式

C++中唯一的三元运算符，条件运算符强大而独特，它提供了一种表达简单if-else语句的简写方法

```c++
逻辑表达式?表达式1:表达式;  //第一个表达式为真，则运行表达式1,表达式1的值为整个条件表达式的值;为假则运行表达式2，2为整个表达式的值
```

#### 其他表达式

记住：任何表达式都有一个确定的值

优先级：  ！>算术表达式>关系表达式>&&和||>赋值表达式

## 3.语法提要

### 输入输出

#### cin和cout

在c++中配合输入输出控制符对基本类型进行输入输出（#include <iomanip>）

```c++
cout<<setiosflags(ios::fixed)<<setprecion(10)<<a; 	   //设置浮点数以固定的小数位显示,10为小数位数
cout<<setiosflags(ios::scientific)<<setprecion<<(6)<<a;//设置浮点数以科学计数法显示,6为小数位数
//以上3个控制符设置一次对以后的输出均有效(除非重新设置)
cout<<setfill('*')<<setw(10)<<a;                       //固定字段宽度为10位，不足前面用*填充
```

#### getchar()和putchar()

C中对字符进行输入输出

```c++
char c;
c=getchar();  //从终端读取一个字符
putchar(c);   //输出一个字符
cout<<getchar;//输出字符的ASCII码
cout<<(c=getchar());//输出字符
```

#### scanf和printf

C中对所有基本类型进行输入输出

```c++
scanf(格式控制,输入表列),如scanf("%d %c %f",&a,&b,&c)
printf(格式控制,输出表列),如printf("a=%d,b=%c,c=%f\n",a,b,c)
```

### if语句

```c++
if(x==0) y=1;  
if(x>0) y=1;
else if(x=0) y=0;  //可以有0个或多个else if
	if(x!=0) y=-1; //可以随便嵌套，程序会自动分辨对应的级别
else			   //若是多个语句则放在大括号里
{
    y=-1;
    cout<<y;
}
```

### switch语句

```c++
switch(表达式)  //这里的表达式是数值类型(包括字符类型)数据
{
    case 常量表达式1:语句1;  //可以是多个语句写在一行
    case 常量表达式2:语句2;  //进入到一个case语句中会一直往下执行，所以一般需要用break跳出当前大括号
    default :语句n;
}
```

### while循环语句

```c++
while(表达式) 执行语句;  //先判断后执行。若是复合语句，用大括号括起来放在下面
do
    语句               //先执行后判断。若是复合语句，用大括号括起来放在下面
while(表达式)；         //注意while后面有;
```

### for循环语句

```c++
for(循环变量设初值;循环条件;循环变量增值)  语句;  //若是复合语句，用大括号括起来放在下面
for(循环变量设初值;循环条件;循环变量增值);       //还可以后面不跟执行语句，将执行语言放在第二或第三个表达式里
//for括号内的三个表达式都可以适当省略
```

## 4.函数

一个函数function就是一个功能，C++中除主函数的大多数函数都封装在类中。

int max(int x,int y)    //如果函数值的类型和return语句返回的值类型不一致，以函数类型为准，自动进行类型转换

函数的实参变量对形参变量的数据传递是"值传递",即单向传递，调用结束后，形参单元被释放，实参单元仍维持原值不变

函数原型(function prototype)：int max(int,int),在函数声明时可以不写形参名(写了也可以与定义函数时不相同)，只写形参类型，在编译时会根据函数原型对调用函数的合法性进行检查。

### 函数的嵌套调用

所有的函数都是平行的(包括main函数),在定义函数时是独立的，函数不能**嵌套定义**，既不能在定义一个函数的过程中又定义另一个函数，也不能把函数的定义部分写在主函数中。

但C++可以嵌套调用函数，即在调用一个函数的过程中又调用另一个函数。可以把函数2在函数1中声明，但把函数2的定义写在函数1的外面。

### 函数的递归调用

在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用(recursive)

```c++
//用递归方法求n!
long fac(int n)   //无需再函数前面添加recursive
{
    long f;  //关键是用一个变量代表函数返回值
    if(n<0) {cout<<"n<0,data error!";return -1;}
    else if(n=1||n=0) f=1;  //设置递归结束条件
    else f=n*f(n-1);
    return f;
}
```

### 内置函数

inline int max(int ,int)  //当函数规模很小时，函数调用的时间甚至超过执行函数本身的时间，为提高效率，在编译时直接将函数的代码嵌入到主调函数中，而不是将流程转出去。适用于规模很小而频繁使用的函数(如定时采集数据的函数),在函数中不能包含复杂的控制语句(如循环语句和switch语句)

### 函数的重载

function overloading.对一个函数名重新赋予新的含义，实现"一物多用"，一般一些功能相近的函数可以用函数重载。

C++允许用同一个函数名定义多个函数，这些函数的参数个数和参数类型和函数的返回类型和函数体可以不同，但要求函数的参数个数、参数类型或参数顺序三者中必须至少有一个不同，否则无法知道调用的是哪个函数。

### 函数模板

function template:建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚的类型来代表。凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。适用于函数体和参数个数相同而类型不同的情况，对函数的重载进行了进一步的化简。

```c++
template<typename T>  //模板声明，其中T类型参数，可以根据需要声明多个,typename也可以写成class,可以互换，都表示类型名
T max(T a,T b)
{
    return(a>b?a:b);
}
```

### 有默认参数的函数

int max(int a,int b,int c=0,float d=0)
实参与形参的结合是从左到右的，因此指定了默认值的参数必须都放在形参列表的最右端
如果函数的定义在函数调用之前，则应在函数定义中给出默认值。如果函数的定义在函数调用之后，则在函数声明中给出默认值，函数定义中可以不给出。也就是说，必须在函数调用前将默认值的信息通知编译系统。

### 内部函数和外部函数

静态函数: 在函数定义前面加static，则该函数只能被本文件中的函数调用，不能被其他文件调用

外部函数: 在函数声明前加extern ，表明该函数定义在另一个文件。用函数原型定义的话，extern可以省略不写

## 5.数组

数组是属于线性表的线性存储结构。所谓数组，就是用一个统一的名字代表这批数据，而用序号或下标来区分各个数据。

### 定义和引用数组

类型名 数组名[常量表达式]         如：int a[10]; int a[2*n]  前面已经定义了n为常变量。
常量表达式可以包括常量，常变量和符号常量，但不能包含变量，即不能对数组大小做动态定义。

#### 数组的初始化

在定义时对全部元素赋值，如int a[5]={1,2,3,4,5};

在定义时对部分元素赋值,如int a[5]={1,2};int a[2] [3]={{1,2},{3,4},{5,6}}或 int a[2] [3]={1,2,3,4,5,6};  int a[][][3] [4]={{1},{1,2},{}};
未赋值的元素系统会根据元素类型自动指定其值(数值型为0,字符型为空字符'\0')

在对全部元素赋初值时，可以不指定数组长度，系统会自动判定(默认给出的全部元素的个数就是数组的长度)。
如int a[]={1，2，3，4，5}.
但对于二维数组或多维数组,只能省略第一维的长度。如int a[] [4]={1,1,1,1,2,2,2,2};

#### 数组名

一维数组名a是一个指针，其值是数组第一个元素的地址。如int *p=&a[0]与int *p=a等价。数组名是指针常量，不能改变，如：不能a++,但可以用表达式a+1。

对于二维数组，a[0],a[1]就是一个指针，指向每行的起始元素。

数组元素和普通变量一样，可以随便赋值引用等。但**数组名代表一个固定的地址，不能赋值**，即数组除在初始化时不能整体赋值，如不能a={1,2,3,4,5}或两个数组相互赋值a=b;

数组名做函数参数，如void selcet(int arry[])或void select(int *p)       实参可以是数组名或者指针变量，形参可以写元素个数也可以不写，C++只是把形参数组名作为一个**指针变量**来处理，从而接受从实参传过来的地址。
做实参，如select(a)：用数组名做实参时，传递的是首元素的地址(址传递)，如果改变了形参数组元素的值，实参数组也会同样改变。

### 字符数组和字符串类型

#### 字符数组

即元素是字符的数组，这是C语言采取的方法，一般称为C-string

**字符数组初始化：**char c[5]={'a','b','c','d','e'}	还可以用字符串常量来进行初始化,如char c[]={"I love China"}或="I love China";
注意:“I like”返回的是一个字符串的首字符的地址，系统会自动给字符串常量后面加一个'\0'作为结束标志，在内存中多占一个字节。赋值时'\0'也会赋给字符数组，如char c[]={"I love China"}或="I love China"会使数组的长度自动设为13(比字符数目多一个)。

字符数组可以一次性输入输出，如cin>>a;cout<<a; 但数值型数组不能一次性输入输出。

##### 字符串处理函数

需要#include <string>

字符串连接函数**strcat:**
函数原型为strcat(char [],const char[], （用const保证数组2的内容不会在函数调用期间被修改）将2加到1后面，函数返回值是第一个字符数组的地址

字符串复制函数**strcpy:**

函数原型为strcpy(char [],const char [])，将第2个字符数组的字符串赋值到第一个字符数组中去，将第一个字符数组中的相应字符覆盖。
strcpy(a,"I love China",2)，将前面两个字符赋值到a

字符串比较函数**strcmp：**
函数原型为strcmp(const char [],const char[])，返回值是一个整数：1=2，返回0；1>2，返回正整数；1<2，返回负整数。字符数组名或字符串常量不能直接比较大小,如str1>str2,"I Love"<"I like"

字符串长度函数**strlen:**
函数原型为strlen(const char [])，返回值是字符串的实际长度，不包括'\0'

**以上处理函数的实参和形参都是指针变量**

#### 字符串类型

C++提供了一个新的数据类型，字符串类型，string，用法与其他基本数据类型一样。

需要#include <string>

string string1="China";

字符串可以直接赋值，可以用+连接两个字符串，字符串的比较可以直接用关系运算符。

##### 字符串数组

string name[3]={"zhang","li","yang"}

## 6.指针

### 定义和引用指针

在程序中一般是通过变量名来对内存单元进行存取操作，变量名在编译时转变为变量的地址，这种按变量地址存取变量值的方式为**直接存取**方式。

将一个变量的地址存放在另一个变量中，叫做**间接存取**。这种专门用来存放地址的变量叫做指针变量。指针变量的值/变量的地址叫做指针。

&:取地址运算符		*:指针运算符

定义指针变量 int *p;	不能用一个整数给指针变量赋值，如int *p=2000;  只能将一个指针赋给指针变量，如p=&a;  

若定义int *p=&a，则p=&a,  \*p=a, &\*p=&a,	*&a=a;

指针变量可以运算，如p+1或p++表示当前地址加上一个所指向数据类型占据的地址。

### 指向数组元素的指针

数组名代表首元素的地址(与一般的变量名不同)，int *p=a与int *p=&a[0]等价，指向数组元素的指针与指向一般变量的指针一样，没有指向数组的指针，只有指向数组某一元素的指针。

若定义int *p=a，则p+i,a+i,&a[i]等价，都是指向数组第i个元素的地址。
			*(p+i), \*(a+i), a[i], p[i]等价，都是数组第i个元素的值。

(若指针指向一般的变量，如int int *p=&a,则p与&a等价，\*p与a等价；若指针指向数组元素int *p=a，则p与a等价)

### 用字符指针指向字符串

char *p="I love China"，或char *p,p="I love China"。使p的值为字符串第一个字符的地址。

```c++
//利用字符指针将字符串1复制给字符串2
char str1[]="I love China",str2[20],*p1,*p2;
p1=str1;p2=str2;
for(;*p1!='\0';p1++,p2++)
    *p2=*p1;
*p2='\0';
p1=str1;p2=str2;
cout<<"str1 is:"<<p1<<endl;
cout<<"str2 is:"<<p2<<endl;
```

### 函数与指针

#### 函数指针

指针变量可以指向一个函数。一个函数在编译时被分配给一个入口地址，这个函数入口地址就是函数的指针。可以用一个函数指针指向函数，然后通过调用此指针调用此函数。

定义：int (*p)(int,int)

赋值：int max(int x,int y)，则可以p=max

调用：p(x,y)    	//相当于用函数指针名代替函数名

函数指针还可以做函数参数，在调用时将函数名当实参进行传递。

#### 返回指针值的函数

定义：int *a(int x,int y)

表示此函数的返回值为指针。

### 指针数组

定义：int *a[10]			(int (\*a)[10]为指向包含10个元素的一维数组的指针变量)

如果一个数组，其元素都是指针变量，则成为指针数组。

#### 指向指针的指针

定义：int **p

a+i其实就是指向指针的指针，*(p+i)=a[i]是指针数组第i个元素。

```c++
利用指针数组对字符串进行排序
void sort(char *a[],int n);
void print(char *a[],int n);
char *name[]={"FORTRAN","C","C++","JAVA","PYTHON"};
int n=5;
sort(name,n);
print(name,n);

void sort(char *a[],int n)
{
    char *temp;
    int k;
    for(int i=0;i<n-1;i++)
    {
        k=i;
        for(int j=i;j<n;j++)
        {
            if(strcmp(a[j],a[k])<0) k=j;    
        }
        if(k!=i)
        {
            temp=a[i];             //a[i]=name[i],是指针数组的第i个元素，也是一个指针。
            a[i]=a[k];
            a[k]=a[i];
        }
    }
}

void print(char *a[],int n)
{
    for(int i=0;i<n;i++)
    {
        cout<<a[i]<<endl;    //若定义 char **p=a,则a[i]可以用*(p+i)或p[i]代替。
    }
}
```

### const指针

#### 指向常量的指针变量

定义：const int \**p=&a;
不允许通过指针变量改变它所指向的值，即不能*\*p=2;	但可以改变指针变量的值，如可以p=&b;	变量仍可以改变，如a=2;

#### 常指针

定义：int * const p=&a;
不允许改变常指针的指向，即指针值不能改变，即不能p=&b；但可以改变常指针指向的变量的值，如*p=2;

#### 指向常量的常指针

定义：const int * const p=&a
既不能改变指针变量的指向，也不能通过指针变量改变变量的值。
以上三种方式都不能限制直接通过变量名改变变量的值，要是变量的值绝对不能变，需要定义常变量，const int a=2.

### void指针类型

定义：void *p;

void指针变量，其仍可以有确定的值，但不指向任何类型的数据，可理解为指向空类型或指向不确定的类型。一般作为过渡指针。

可以把非void型的指针赋给void型指针变量，但不能把void指针直接赋给非void 型指针变量，必须先进行强制转换。

```c++
int a=3;
int *p1=&a;
void *p2;
p2=p1或p2=(void *)p1;        //p1的值赋给p2
不能cout<<*p2,应为p2为void指针，需要先转换，可以cout<<*(int *)p2,即输出3
不能p1=p2,可以p1=(int *)p2
```

##### NULL

指针变量可以有空值，即该指针不指向任何变量，但该指针仍是有值的，p=NULL就是p=0，就是使p指向地址为0的单元，即指针不指向任何有效的单元。

### 传值方式与传址方式

#### 引用(reference)

对一个数据建立一个引用，作用是为变量起一个别名。

如：int a; int &b=a;	声明了b是a的引用，即b是a的别名，通过b可以引用a，也就是b和a是同一个东西了。改变了引用的值也会改变变量的值，也可以对引用取地址，如&b即是&a。声明完引用后不能再重新声明其为另一个变量的引用。

引用不是一种独立的数据类型，对引用只有声明，没有定义，在声明一个引用时必须使之初始化，即声明它代表哪个变量。

C++之所以增加引用机制，主要是把它作为函数参数，以扩充函数传递数据的功能，

```c++
#include <iostream>
using namespace;
int main()
{
    void swap(int ,int);
    void swap(int *,int *);
    void swap(int &,int &);
    int i=2,j=3;
    swap(i,j);
    swap(&i,&j);
    swap(i,j);
    return 0;
}

void swap(int i,int j)   //变量作为形参
{
    int temp;
    temp=j;
    j=i;
    i=temp;
}

void swap(int *i,int *j)  //指针作为形参
{
    int temp;
    temp=*j;
    *j=*i;
    *i=temp;
}

void swap(int &i,int &j)  //引用作为形参
{
    int temp;
    temp=j;
    j=i;
    i=temp;
}

/*
前两种方式传递的都是实参的值，属于传值方式。第一种传递的是变量的值，第二种传递的是指针变量的值(即地址)，这两种方式在调用函数过程中都不能改变实参的值。且在调用函数过程中需要为形参分配存储单元，用来接收实参的值，实参和形参的存储单元不同，第一种方式开辟的空间与实参所需空间相同(可能需要很多个字节)，第二种方式需要开辟一个空间存放指针(一般为4个字节)。虽然第二中方式可以通过形参指针变量改变实参的值，但是却兜了一个圈子，不那么直接了当。

第三种方式传递的是实参的地址，属于传址方式。可以把实参的地址传递给形参，使形参作为实参的引用，使形参和实参的地址相同。改变形参即可直接改变实参，且不需要为形参额外开辟空间。这种方式更加方便直接。
*/
```

### 利用指针的优点

* 用法比较灵活，可以提高编程效率
* 用指针变量作为函数参数，在调用函数过程中可以改变实参所指向的变量的值
* 可以实现动态存储分配

## 7.自定义数据类型

### 结构体类型

在一个组合项中包含若干类型不同(当然也可以相同)的数据类型，叫做结构体。

```c++
声明：struct Student    //结构体类型名，相当于int ,float等基本类型。结构体类型名可以省略直接定义结构体变量，但是不建议这样做
{                      //声明结构体类型时不分配空间，而定义结构体变量时需要分配空间
    int num;           //每个成员也称一个域(filed)，成员表又成为域表
    char name[20];     //包含字符数组的话需要指定数组长度
    Date birtgday      //Date是另一个结构体类型名，一个结构体中可以包含两一个结构体
    Student *p;        //指向自身类型的指针
}  stu1[3]={{101,"cuiyugui1",2020,03,15,NULL},{102,"cuiyugui2",2020,03,15,NULL},{103,"cuiyugui3",2020,03,15,NULL}}；
//可以在声明时定义和初始化结构体变量，也可以先声明后定义。结构体变量和普通变量一样，可以随意操作，包括取地址。
//结构体变量可以整体赋值或相同类型结构体变量相互赋值，但不能整体输入输出。
引用结构变量：结构体变量名.成员名        如stu1[1].num=108;
```

#### 指向结构体变量的指针

Student \*p=&student      //指针类型要用结构体类型，而不能用结构体变量。结构体变量名与数组名不同，不代表地址，需要加&。
//定义后，\*p等价与student，即student.num=(*p).num=p->num

```c++
结构体变量可以做函数参数，指向结构体变量的指针可以做函数参数，结构体变量的引用也可以做函数参数
    void print(Stu stu1);    
    void print(Stu  *);
    void print(Stu &);
```

#### 用new和delete运算符进行动态分配和撤销存储空间

C++提供new和delect来代替malloc和free，new和delete是运算符，不是函数，执行效率高。

 ```c++
new int;     //开辟一个存放整数类型的空间，并返回一个指向该存储空间的地址
new int(10)  //开辟一个存放整数类型的空间，指定其初值为10，并返回一个指向该存储空间的地址
int *p=new int(10) //开辟一个存放整数类型的空间，指定其初值为10，并返回一个指向该存储空间的地址给指针变量p
new char[5]  //开辟一个存放字符数组(包含5个元素)的的空间，并返回一个指向该存储空间的地址。用new分配数组空间不能指定初值
Stu *p=new Stu //动态开辟结构体类型空间，可以建立动态链表
//如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据返回指针的值判断分配空间是否成功
    
delete用法：delete 指针变量      //撤销指针变量所指向的变量的空间
           delete [] 指针变量   //撤销指针变量所指向的数组的空间
 ```

### 共用体类型

```c+
union Data 
{
int i;           
char n;
double f;
};
//共用体与结构体不同之处在于：系统为结构体中各成员分别分配存储单元，而共用体则是个成员共用一段存储单元。这样可以节省空间。
```

### 枚举类型

枚举(enumeration)类型的枚举变量只能用几种不同的取值。利用枚举变量可以把变量的值限制在一定范围内。

```c++
enum weekday{sun,mon,tue,wed,thu,fri,sat};   //声明枚举类型
weekday week1;    //定义枚举变量
//枚举元素按常量处理，故称枚举常量，不能对枚举元素赋值。
//枚举元素的值按顺序自动赋值为0，1，2...相当于设置了符号常量，可以进行数值运算，如for(int i=sun;i<=sat;i++)。
//可以输出枚举变量，但输出的是整数，如cout<<week1输出的是0
//不能把一个整数直接赋给一个枚举变量，枚举变量只能接受枚举类型数据，如week1=tue;要把整数赋给枚举变量，必须进行强制类型转换，如week1=weekday(2),相当于week1=tue;
```

### 用typedef声明新的类型名

声明一个新的类型名的方法：

1. 先按定义变量的方法写出定义语句，如int a[10]
2. 将变量名换成新的类型名，int NUM[10]
3. 在最前面加上typedef ，typedef int NUM[10]
4. 然后可以用新的类型名去定义变量，NUM a，a就是一个有是个元素的数组名，a[1]就是数组的第一个元素

```c++
typedef int INTEGER  
typedef struct    //这里不要写结构体类型名
{
    int month;
    int day;
    int year;
} DATA;   //声明DATA代表上面指定的结构体类型
typedef char * STRING  //声明STRING为字符指针类型
typedef int (*Pointer_to_Function)()   //声明Pointer_to_Function为指向函数的指针类型 
//用trpedef相当与给类型名取一个别名，并没有创造新的类型
//用typedef可以声明数组类型，字符串类型，使用比较方便
    如typedef int ARR[10]，ARR a,b,c。
```

#### 优点

* 开发程序时常用typedef声明不同的数据类型，把他们单独放在一个头文件中，可以用#include把它们包括到本文件中，就可以使用这些typedef类型名。这样方便编程，提供编程效率
* 使用typedef类型名去定义变量，可以在修改typedef声明时一次性修改全部变量的类型，有利于程序的通用和移植。

---



# C++面向对象编程(OOP-Object Oriented Programing)

## 1.类和对象

## 2.继承

## 3.多态



# C++泛型编程(generic programing)

## 2.标准模板库STL

STL是C++标准的组成部分，不是面向对象编程，而是一种不同的编程模式——泛型编程。

STL提供一组表示容器/迭代器/函数对象和算法的模板，能够构造各种容器(包括数组/队列/链表等)和执行各种操作(包括搜索/排序和随机排列等)。

容器是一个与数组类似的单元，可以动态的存储若干个类型一样的值。

算法是完成特定任务(如对数组进行排序和在链表中查询特定的值)的处方。

函数对象是类似于函数的对象，可以是类对象或函数指针(包括函数名,因为函数名被用作指针)。

### 模板类vector(矢量)

是一种容器类，可以用来创建动态数组，使用动态内存分配，在使用时要#include <vector>

创建一维动态矢量：vector<int>  Nums(n)，矢量中含有n个int 变量，Nums就是一个对象，Nums[2]表示矢量中的第3个元素。

创建二维动态矢量：vector<vector<int>> Nums，默认为0个元素。Nums\[2][3]，可以像数组一样用[]随机访问元素。

所有的STL容器都提供了一些基本，vector模板类也可以使用，如:

```c++
Nums[2].size()   //返回Nums[2]容器中的元素个数
Nums.size()      //返回Nums容器中总的元素个数
Nums[2].swap(Nums[3])  //交换两个容器的内容
Nums.begin()    //返回一个指向容器第一个元素的迭代器
Nums.end()      //返回一个表示超过容器尾的迭代器
Nums[1].empty()  //若Num[1]为空则返回true
vector<int> NewNums(Nums)  //可以用一个已有的矢量去初始化一个新矢量
Nums.push_back(a) //在矢量末尾插入一个元素
Nums.erase(Nums.begin(),Nums.begin()+2)//删除Nums矢量第一个和第二个元素
Nums.insert(a)//在头部插入一个元素
Nums.insert(Nums.end(),Other.begin()+1,Other.end())//将Other矢量的第2个到最后一个元素插到Nums的末尾
Nums.insert(Nums.begin(),Other.begin(),Other.begin()+2)//将Other矢量的第1个到第2个元素插到Nums的头部
```

#### 迭代器

迭代器是一个广义指针，指向容器，能够用来遍历容器的对象，还可以通过解除引用算符*来引用容器，让STL能够为各种不同的容器类(包括那些简单指针无法处理的类)提供统一的接口。

```
声明迭代器:vector<int>::iterator p;//每一个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为iterator的typedef
for(p=Nums[1].begin();p!=Nums[1].end();p++)
cout<<*p;
```

#### 可对矢量执行的其他操作

STL从更广泛的角度定义了一些非成员函数，可用于操作所有容器类，但并不是容器的成员函数。

```c++
for(p=Nums[1].begin();p!=Nums[1].end();p++)
Show(*p);
等价于：for_each(Nums.begin(),Nums.end(),Show)//前两个是定义容器中区间的迭代器,最后一个是指向函数的指针，即函数对象

Random_shuffle(Nums.begin(),Nums.end())//Random_shuffle函数接受两个指定区间的迭代器参数，并随即排列该区间中的元素
    
sort(Nums.begin(),Nums.end())
//Sort函数可以对容器指定区间的元素进行排序。如果容器元素是用户自定义的对象，需要先对容器元素类型重载运算符<，如果是基类型则不必。
sort(Nums.begin(),Nums.end(),WorseThan)//可以按照WorseThan定义的比较方法对容器中的元素进行排序
```

