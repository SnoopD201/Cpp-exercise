# C++基础知识整理归纳

## 1.C++初步知识

低级语言：机器或汇编语言

1954年出现高级语言FORTRAN，之后出现C(1972年有贝尔实验室的D.M.Ritchie发明)和BASIC(1964年在FORTRAN语言的基础上简化而来)，1980年贝尔实验室的Bjarne Stroustrup发明C++。

C语言：是结构化和模块化的语言，是基于过程的。容易处理较小规模的程序，但当问题比较复杂，程序规模较大时，结构话语言就显得不足。

C++：(1).在基于过程的机制基础上，对C语言做了不少扩充。 (2).增加了面向对象的机制

C++的特点：

>1. 类可以体现数据的封装性和信息屏蔽

C++的实现过程：

>1. 用C++语言编写程序，生成.cpp文件
>2. 编译:用编译器(complier)把原程序翻译成二进制的目标程序，生成.obj文件
>3. 连接：用系统提供的连接程序(linker)将所有的目标文件和系统的库函数以及系统提供的某些其他信息连接起来，生成可执行文件.exe
>4. 运行程序：运动最终形成的可执行的二进制文件(.exe)，得到运行结果



### 最简单的C++程序

```c++
#include <iostream>   //预处理指令,在程序进行编译时，将先对所有的预处理指令进行处理，将头文件的具体内容插入到include处
using namespace std;  //使用命名空间std,C++标准库中的类和函数是在命名空间std中声明的
int main()            //一个c++程序总是从main函数开始执行，若程序不能正常执行，向系统返回一个非零值(一般是-1)
{
    int a;
    cin>>a;
    cout<<a;
    return 0;
}
```

### 头文件

头文件是源文件之间的接口。利用#include指令，可以把不同的文件组合在一起，形成一个文件，避免重复编写代码，提高了编程效率。

头文件(.h)一般包含以下几类：

* 对类型的声明：对结构体或类的声明(而真正的定义放在源文件中)
* 函数声明：为方便用户，可以将同一类的函数声明集中在一个头文件中(如cmath集中了各类数学函数的原型声明)。而函数的定义不是放在头文件中，而是放在函数库或单独编译成目标文件，在编译阶段与用户文件连接组成可执行文件。
* 内置函数的定义：直接定义不要再声明了
* 宏定义：用define定义的符号常量和用const声明的常变量
* 全局变量声明
* 外部变量声明:如extern int a;
* 根据需要可以包含其他头文件

## 2.数据类型与表达式

### c++的数据类型

> 基本类型
>
> > 整形
> >
> > > 短整型(short int 或short)
> > >
> > > 整形(int)
> > >
> > > 长整型(long int 或long)：数字末尾加L或者l表示长整型，前面加0表示8进制，前面加0x表示16进制
> > >
> > > 整型数据之间的赋值：
> > > 按存储单元中的存储形式直接传送。如short int类型的-1以补码形式储存为1111111111111111，赋值给unsigned int则变成了65535.
> > > 将整型赋值给char型，只将其低8位原封不动的送给char型变量.
> > >
> > > 补码：
> > > 在计算机中，数值的存储一律用补码，因为补码可以将符号位与数值域统一处理，加法和减法也可以统一处理。
> > > 符号位:0表示正数，1表示负数
> > > 原码求补码:正数与原码相同，负数将原码除符号位取反再加1，0的补码表示是唯一的00000000.
> >
> > 字符型(char)
> >
> > > 普通字符常量：用单撇号括起来。字符常量使用ASCII码存储的，可以与整数进行混合运算。A对应的ASCII码为65，a对应97。
> > >
> > > 转义字符：'\n'等。 
> > >
> > > 字符串常量：用双撇号括起来，在计算机中存储时会在末尾加一个\0，多占一个字节
> > >
> > > ```c++
> > > 从左到右看,如"I say \"thanks\"\n"为I say "thanks"然后换行
> > > ```
> >
> > 浮点型：可以写成十进制小数形式或者指数形式，但在内存中都是以指数形式(即浮点形式)进行存储，符号在前面，小数部分在中间，指数部分在后面。在存储单元中小数部分和指数部分都是用二进制表示的，不能无限精确。
> >
> > > 单精度型(float)：6为有效数字，4个字节
> > >
> > > 双精度型(double)：15位有效数字，8个字节
> > >
> > > 长双精度型(long double)
> >
> > 布尔型(bool)
> >
> > > false=0,true=1.布尔型可以与数值型数据进行混合运算，true当成1,false当成0，cout<<true为输出1.
>
> 空类型(void)
>
> 派生类型
>
> > 指针类型(*)
> >
> > 数组类型([])
> >
> > 类类型(class)
> >
> > 共用体类型(union)
> >
> > 枚举类型(enum)
> >
> > 结构体类型(struct)
> >
>

### 符号常量

为方便编程和阅读，用一个标识符代表一个字符串常量，在预编译时把所有的符号常量换成所指定的字符串。如：

```c++
#define 宏名 字符串
#define uchar unsigned char  //自己定义的符号放中间
```

特点是含义清楚，可以做到“见名知意”，一个在修改一个常量时可以“一改全改”

#### 符号常量与const常变量的区别：

在定义常变量时必须同时对它初始化(即指定其值)，此后不能再对其赋值。const int a=3;

符号常量只是用一个符号代表一个字符串，在编译时把所有符号常量替换为指定的字符串，它没有类型，没有名字，在内存中并不存在以符号常量命名的存储单元。而常变量是一个变量，有名字，在存储中有以它命名的存储单元，可以用sizeof测出其长度，只是其值不能修改。且常变量可以是字符或数值型，符号常量只代表一个字符串。

### 变量

变量有三个属性，存储类别，作用域，存储期

#### 作用域

##### 局部变量

local variable.在一个函数或复合语句内部定义的变量是内部变量，它只在本函数或本复合语句在有效，在外部无效。在main函数在定义的变量也不可以在其他函数中使用。

##### 全局变量

global variable.在函数之外定义的变量为全局变量，其有效范围从定义变量的位置开始到源文件结束。如在main函数上面定义的全局变量可以在所有函数中使用,且在其他函数中不需要再定义一次。如在同一个源文件中，全局变量和局部变量重名，则全局变量被屏蔽。

建议不在必要时不使用全局变量，因为全局变量在程序全部执行过程中都占用存储单元，且它使函数的通用性降低了。
在程序设计时，在划分模块时要求模块的内聚性强，耦合性弱。即模块的功能要单一，与其他模块的相互影响要尽量少。这样程序移植性好，可读性强。

#### 存储类别

内存分为程序区，静态存储区和动态存储区。存储方法有动态存储和静态存储，全局变量放在静态存储区，函数的形式参数、局部变量和函数调用时的现场保护和返回地址等放在动态存储区。

##### 自动变量(auto)

函数中的局部变量，如果不加static声明,就是自动变量，可以加aotu修饰，也可以不加，属于动态存储方式。

##### 用static声明静态局部变量

在函数调用结束后不消失而保留原值。属于静态存储方式。
对静态局部变量是在编译时赋初值的，即只赋值一次。

##### 用register声明寄存器变量

对于使用频繁的变量，不存放在内存中，而直接存储在寄存器中。在函数调用结束后并不保留原值。

##### 用extern声明外部变量

###### 在一个文件内声明全局变量

在一个函数内用extern对变量做外部变量声明，可以提前引用。

###### 在多个文件中声明外部变量

在一个文件内定义int a=3, 在另一个文件中做外部变量声明 extern int a,从而扩展其作用域。不能在多个文件中重复定义外部变量。

##### 用static声明静态外部变量

对外部变量加上static声明,则该外部变量无法被其他文件引用。

### c++运算符与表达式

<img src="D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\运算符和结合性1.png" alt="运算符和结合性1" style="zoom:67%;" />

![运算符和结合性2](D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\运算符和结合性2.png)

![运算符和结合性3](D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\运算符和结合性3.png)

#### 逗号运算符与逗号表达式

x=表达式1，表达式2  //先求解表达式1，再求解表达式2，整个表达式的值就是表达式2的值

```c++
a=5;
a=2*3,4*a;  //a=2*3是表达式1，先得到a=6，然后计算表达式为24,所以整个表达式的值为24.但是a仍为6,因为表达式2没有重新对a进行赋值
```

#### 条件运算符与条件表达式

C++中唯一的三元运算符，条件运算符强大而独特，它提供了一种表达简单if-else语句的简写方法

```c++
逻辑表达式?表达式1:表达式;  //第一个表达式为真，则运行表达式1,表达式1的值为整个条件表达式的值;为假则运行表达式2，2为整个表达式的值
```

#### 其他表达式

记住：任何表达式都有一个确定的值

优先级：  ！>算术表达式>关系表达式>&&和||>赋值表达式

## 3.语法提要

### 输入输出

#### cin和cout

在c++中配合输入输出控制符对基本类型进行输入输出（#include <iomanip>）

```c++
cout<<setiosflags(ios::fixed)<<setprecion(10)<<a; 	   //设置浮点数以固定的小数位显示,10为小数位数
cout<<setiosflags(ios::scientific)<<setprecion<<(6)<<a;//设置浮点数以科学计数法显示,6为小数位数
//以上3个控制符设置一次对以后的输出均有效(除非重新设置)
cout<<setfill('*')<<setw(10)<<a;                       //固定字段宽度为10位，不足前面用*填充
```

#### getchar()和putchar()

C中对字符进行输入输出

```c++
char c;
c=getchar();  //从终端读取一个字符
putchar(c);   //输出一个字符
cout<<getchar;//输出字符的ASCII码
cout<<(c=getchar());//输出字符
```

#### scanf和printf

C中对所有基本类型进行输入输出

```c++
scanf(格式控制,输入表列),如scanf("%d %c %f",&a,&b,&c)
printf(格式控制,输出表列),如printf("a=%d,b=%c,c=%f\n",a,b,c)
```

### if语句

```c++
if(x==0) y=1;  
if(x>0) y=1;
else if(x=0) y=0;  //可以有0个或多个else if
	if(x!=0) y=-1; //可以随便嵌套，程序会自动分辨对应的级别
else			   //若是多个语句则放在大括号里
{
    y=-1;
    cout<<y;
}
```

### switch语句

```c++
switch(表达式)  //这里的表达式是数值类型(包括字符类型)数据
{
    case 常量表达式1:语句1;  //可以是多个语句写在一行
    case 常量表达式2:语句2;  //进入到一个case语句中会一直往下执行，所以一般需要用break跳出当前大括号
    default :语句n;
}
```

### while循环语句

```c++
while(表达式) 执行语句;  //先判断后执行。若是复合语句，用大括号括起来放在下面
do
    语句               //先执行后判断。若是复合语句，用大括号括起来放在下面
while(表达式)；         //注意while后面有;
```

### for循环语句

```c++
for(循环变量设初值;循环条件;循环变量增值)  语句;  //若是复合语句，用大括号括起来放在下面
for(循环变量设初值;循环条件;循环变量增值);       //还可以后面不跟执行语句，将执行语言放在第二或第三个表达式里
//for括号内的三个表达式都可以适当省略
```

## 4.函数

一个函数function就是一个功能，C++中除主函数的大多数函数都封装在类中。

int max(int x,int y)    //如果函数值的类型和return语句返回的值类型不一致，以函数类型为准，自动进行类型转换

函数的实参变量对形参变量的数据传递是"值传递",即单向传递，调用结束后，形参单元被释放，实参单元仍维持原值不变

函数原型(function prototype)：int max(int,int),在函数声明时可以不写形参名(写了也可以与定义函数时不相同)，只写形参类型，在编译时会根据函数原型对调用函数的合法性进行检查。

### 函数的嵌套调用

所有的函数都是平行的(包括main函数),在定义函数时是独立的，函数不能**嵌套定义**，既不能在定义一个函数的过程中又定义另一个函数，也不能把函数的定义部分写在主函数中。

但C++可以嵌套调用函数，即在调用一个函数的过程中又调用另一个函数。可以把函数2在函数1中声明，但把函数2的定义写在函数1的外面。

### 函数的递归调用

在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用(recursive)

```c++
//用递归方法求n!
long fac(int n)   //无需再函数前面添加recursive
{
    long f;  //关键是用一个变量代表函数返回值
    if(n<0) {cout<<"n<0,data error!";return -1;}
    else if(n=1||n=0) f=1;  //设置递归结束条件
    else f=n*f(n-1);
    return f;
}
```

### 内置函数

inline int max(int ,int)  //当函数规模很小时，函数调用的时间甚至超过执行函数本身的时间，为提高效率，在编译时直接将函数的代码嵌入到主调函数中，而不是将流程转出去。适用于规模很小而频繁使用的函数(如定时采集数据的函数),在函数中不能包含复杂的控制语句(如循环语句和switch语句)

### 函数的重载

function overloading.对一个函数名重新赋予新的含义，实现"一物多用"，一般一些功能相近的函数可以用函数重载。

C++允许用同一个函数名定义多个函数，这些函数的参数个数和参数类型和函数的返回类型和函数体可以不同，但要求**函数的参数个数、参数类型或参数顺序**三者中必须至少有一个不同，否则无法知道调用的是哪个函数。

### 函数模板

function template:建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚的类型来代表。凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。适用于函数体和参数个数相同而类型不同的情况，对函数的重载进行了进一步的化简。

```c++
template<typename T>  //模板声明，其中T类型参数，可以根据需要声明多个,typename也可以写成class,可以互换，都表示类型名
T max(T a,T b)
{
    return(a>b?a:b);
}
```

### 有默认参数的函数

int max(int a,int b,int c=0,float d=0)
实参与形参的结合是从左到右的，因此指定了默认值的参数必须都放在形参列表的最右端
如果函数的定义在函数调用之前，则应在函数定义中给出默认值。如果函数的定义在函数调用之后，则在函数声明中给出默认值，函数定义中可以不给出。也就是说，必须在函数调用前将默认值的信息通知编译系统。

### 内部函数和外部函数

静态函数: 在函数定义前面加static，则该函数只能被本文件中的函数调用，不能被其他文件调用

外部函数: 在函数声明前加extern ，表明该函数定义在另一个文件。用函数原型定义的话，extern可以省略不写

## 5.数组

数组是属于线性表的线性存储结构。所谓数组，就是用一个统一的名字代表这批数据，而用序号或下标来区分各个数据。

### 定义和引用数组

类型名 数组名[常量表达式]         如：int a[10]; int a[2*n]  前面已经定义了n为常变量。
常量表达式可以包括常量，常变量和符号常量，但不能包含变量，即不能对数组大小做动态定义。

#### 数组的初始化

在定义时对全部元素赋值，如int a[5]={1,2,3,4,5};

在定义时对部分元素赋值,如int a[5]={1,2};int a[2] [3]={{1,2},{3,4},{5,6}}或 int a[2] [3]={1,2,3,4,5,6};  int a[][][3] [4]={{1},{1,2},{}};
未赋值的元素系统会根据元素类型自动指定其值(数值型为0,字符型为空字符'\0')

在对全部元素赋初值时，可以不指定数组长度，系统会自动判定(默认给出的全部元素的个数就是数组的长度)。
如int a[]={1，2，3，4，5}.
但对于二维数组或多维数组,只能省略第一维的长度。如int a[] [4]={1,1,1,1,2,2,2,2};

#### 数组名

一维数组名a是一个指针，其值是数组第一个元素的地址。如int *p=&a[0]与int *p=a等价。数组名是指针常量，不能改变，如：不能a++,但可以用表达式a+1。

对于二维数组，a[0],a[1]就是一个指针，指向每行的起始元素。

数组元素和普通变量一样，可以随便赋值引用等。但**数组名代表一个固定的地址，不能赋值**，即数组除在初始化时不能整体赋值，如不能a={1,2,3,4,5}或两个数组相互赋值a=b;

数组名做函数参数，如void selcet(int arry[])或void select(int *p)       实参可以是数组名或者指针变量，形参可以写元素个数也可以不写，C++只是把形参数组名作为一个**指针变量**来处理，从而接受从实参传过来的地址。
做实参，如select(a)：用数组名做实参时，传递的是首元素的地址(址传递)，如果改变了形参数组元素的值，实参数组也会同样改变。

### 字符数组和字符串类型

#### 字符数组

即元素是字符的数组，这是C语言采取的方法，一般称为C-string

**字符数组初始化：**char c[5]={'a','b','c','d','e'}	还可以用字符串常量来进行初始化,如char c[]={"I love China"}或="I love China";
注意:“I like”返回的是一个字符串的首字符的地址，系统会自动给字符串常量后面加一个'\0'作为结束标志，在内存中多占一个字节。赋值时'\0'也会赋给字符数组，如char c[]={"I love China"}或="I love China"会使数组的长度自动设为13(比字符数目多一个)。

字符数组可以一次性输入输出，如cin>>a;cout<<a; 但数值型数组不能一次性输入输出。

##### 字符串处理函数

需要#include <string>

字符串连接函数**strcat:**
函数原型为strcat(char [],const char[], （用const保证数组2的内容不会在函数调用期间被修改）将2加到1后面，函数返回值是第一个字符数组的地址

字符串复制函数**strcpy:**

函数原型为strcpy(char [],const char [])，将第2个字符数组的字符串赋值到第一个字符数组中去，将第一个字符数组中的相应字符覆盖。
strcpy(a,"I love China",2)，将前面两个字符赋值到a

字符串比较函数**strcmp：**
函数原型为strcmp(const char [],const char[])，返回值是一个整数：1=2，返回0；1>2，返回正整数；1<2，返回负整数。字符数组名或字符串常量不能直接比较大小,如str1>str2,"I Love"<"I like"

字符串长度函数**strlen:**
函数原型为strlen(const char [])，返回值是字符串的实际长度，不包括'\0'

**以上处理函数的实参和形参都是指针变量**

#### 字符串类型

C++提供了一个新的数据类型，字符串类型，string，用法与其他基本数据类型一样。

需要#include <string>

string string1="China";

字符串可以直接赋值，可以用+连接两个字符串，字符串的比较可以直接用关系运算符。

##### 字符串数组

string name[3]={"zhang","li","yang"}

## 6.指针

### 定义和引用指针

在程序中一般是通过变量名来对内存单元进行存取操作，变量名在编译时转变为变量的地址，这种按变量地址存取变量值的方式为**直接存取**方式。

将一个变量的地址存放在另一个变量中，叫做**间接存取**。这种专门用来存放地址的变量叫做指针变量。指针变量的值/变量的地址叫做指针。

&:取地址运算符		*:指针运算符

定义指针变量 int *p;	不能用一个整数给指针变量赋值，如int *p=2000;  只能将一个指针赋给指针变量，如p=&a;  

若定义int *p=&a，则p=&a,  \*p=a, &\*p=&a,	*&a=a;

指针变量可以运算，如p+1或p++表示当前地址加上一个所指向数据类型占据的地址。

### 指向数组元素的指针

数组名代表首元素的地址(与一般的变量名不同)，int *p=a与int *p=&a[0]等价，指向数组元素的指针与指向一般变量的指针一样，没有指向数组的指针，只有指向数组某一元素的指针。

若定义int *p=a，则p+i,a+i,&a[i]等价，都是指向数组第i个元素的地址。
			*(p+i), \*(a+i), a[i], p[i]等价，都是数组第i个元素的值。

(若指针指向一般的变量，如int int *p=&a,则p与&a等价，\*p与a等价；若指针指向数组元素int *p=a，则p与a等价)

### 用字符指针指向字符串

char *p="I love China"，或char *p,p="I love China"。使p的值为字符串第一个字符的地址。

```c++
//利用字符指针将字符串1复制给字符串2
char str1[]="I love China",str2[20],*p1,*p2;
p1=str1;p2=str2;
for(;*p1!='\0';p1++,p2++)
    *p2=*p1;
*p2='\0';
p1=str1;p2=str2;
cout<<"str1 is:"<<p1<<endl;
cout<<"str2 is:"<<p2<<endl;
```

### 函数与指针

#### 函数指针

指针变量可以指向一个函数。一个函数在编译时被分配给一个入口地址，这个函数入口地址就是函数的指针。可以用一个函数指针指向函数，然后通过调用此指针调用此函数。

定义：int (*p)(int,int)

赋值：int max(int x,int y)，则可以p=max

调用：p(x,y)    	//相当于用函数指针名代替函数名

函数指针还可以做函数参数，在调用时将函数名当实参进行传递。

#### 返回指针值的函数

定义：int *a(int x,int y)

表示此函数的返回值为指针。

### 指针数组

定义：int *a[10]			(int (\*a)[10]为指向包含10个元素的一维数组的指针变量)

如果一个数组，其元素都是指针变量，则成为指针数组。

#### 指向指针的指针

定义：int **p

a+i其实就是指向指针的指针，*(p+i)=a[i]是指针数组第i个元素。

```c++
利用指针数组对字符串进行排序
void sort(char *a[],int n);
void print(char *a[],int n);
char *name[]={"FORTRAN","C","C++","JAVA","PYTHON"};
int n=5;
sort(name,n);
print(name,n);

void sort(char *a[],int n)
{
    char *temp;
    int k;
    for(int i=0;i<n-1;i++)
    {
        k=i;
        for(int j=i;j<n;j++)
        {
            if(strcmp(a[j],a[k])<0) k=j;    
        }
        if(k!=i)
        {
            temp=a[i];             //a[i]=name[i],是指针数组的第i个元素，也是一个指针。
            a[i]=a[k];
            a[k]=a[i];
        }
    }
}

void print(char *a[],int n)
{
    for(int i=0;i<n;i++)
    {
        cout<<a[i]<<endl;    //若定义 char **p=a,则a[i]可以用*(p+i)或p[i]代替。
    }
}
```

### const指针

#### 指向常量的指针变量

定义：const int \**p=&a;
不允许通过指针变量改变它所指向的值，即不能*\*p=2;	但可以改变指针变量的值，如可以p=&b;	变量仍可以改变，如a=2;

#### 常指针

定义：int * const p=&a;
不允许改变常指针的指向，即指针值不能改变，即不能p=&b；但可以改变常指针指向的变量的值，如*p=2;

#### 指向常量的常指针

定义：const int * const p=&a
既不能改变指针变量的指向，也不能通过指针变量改变变量的值。
以上三种方式都不能限制直接通过变量名改变变量的值，要是变量的值绝对不能变，需要定义常变量，const int a=2.

### void指针类型

定义：void *p;

void指针变量，其仍可以有确定的值，但不指向任何类型的数据，可理解为指向空类型或指向不确定的类型。一般作为过渡指针。

可以把非void型的指针赋给void型指针变量，但不能把void指针直接赋给非void 型指针变量，必须先进行强制转换。

```c++
int a=3;
int *p1=&a;
void *p2;
p2=p1或p2=(void *)p1;        //p1的值赋给p2
不能cout<<*p2,应为p2为void指针，需要先转换，可以cout<<*(int *)p2,即输出3
不能p1=p2,可以p1=(int *)p2
```

##### NULL

指针变量可以有空值，即该指针不指向任何变量，但该指针仍是有值的，p=NULL就是p=0，就是使p指向地址为0的单元，即指针不指向任何有效的单元。

### 传值方式与传址方式

#### 引用(reference)

对一个数据建立一个引用，作用是为变量起一个别名。

如：int a; int &b=a;	声明了b是a的引用，即b是a的别名，通过b可以引用a，也就是b和a是同一个东西了。改变了引用的值也会改变变量的值，也可以对引用取地址，如&b即是&a。声明完引用后不能再重新声明其为另一个变量的引用。

引用不是一种独立的数据类型，对引用只有声明，没有定义，在声明一个引用时必须使之初始化，即声明它代表哪个变量。

C++之所以增加引用机制，主要是把它作为函数参数，以扩充函数传递数据的功能，

```c++
#include <iostream>
using namespace;
int main()
{
    void swap(int ,int);
    void swap(int *,int *);
    void swap(int &,int &);
    int i=2,j=3;
    swap(i,j);
    swap(&i,&j);
    swap(i,j);
    return 0;
}

void swap(int i,int j)   //变量作为形参
{
    int temp;
    temp=j;
    j=i;
    i=temp;
}

void swap(int *i,int *j)  //指针作为形参
{
    int temp;
    temp=*j;
    *j=*i;
    *i=temp;
}

void swap(int &i,int &j)  //引用作为形参
{
    int temp;
    temp=j;
    j=i;
    i=temp;
}

/*
前两种方式传递的都是实参的值，属于传值方式，会开辟新的内存单元，进行虚实结合。第一种传递的是变量的值，第二种传递的是指针变量的值(即地址)，这两种方式在调用函数过程中都不能改变实参的值。且在调用函数过程中需要为形参分配存储单元，用来接收实参的值，实参和形参的存储单元不同，第一种方式开辟的空间与实参所需空间相同(可能需要很多个字节)，第二种方式需要开辟一个空间存放指针(一般为4个字节)。虽然第二中方式可以通过形参指针变量改变实参的值，但是却兜了一个圈子，不那么直接了当。

第三种方式传递的是实参的地址，属于传址方式。可以把实参的地址传递给形参，使形参作为实参的引用，使形参和实参的地址相同。改变形参即可直接改变实参，且不需要为形参额外开辟空间，不生成临时变量(实参的副本)。这种方式更加方便直接，减少了时间和空间的开销。
*/
```

### 利用指针的优点

* 用法比较灵活，可以提高编程效率
* 用指针变量作为函数参数，在调用函数过程中可以改变实参所指向的变量的值
* 可以实现动态存储分配

## 7.自定义数据类型

### 结构体类型

在一个组合项中包含若干类型不同(当然也可以相同)的数据类型，叫做结构体。

```c++
声明：struct Student    //结构体类型名，相当于int ,float等基本类型。结构体类型名可以省略直接定义结构体变量，但是不建议这样做
{                      //声明结构体类型时不分配空间，而定义结构体变量时需要分配空间
    int num;           //每个成员也称一个域(filed)，成员表又成为域表
    char name[20];     //包含字符数组的话需要指定数组长度
    Date birtgday      //Date是另一个结构体类型名，一个结构体中可以包含两一个结构体
    Student *p;        //指向自身类型的指针
}  stu1[3]={{101,"cuiyugui1",2020,03,15,NULL},{102,"cuiyugui2",2020,03,15,NULL},{103,"cuiyugui3",2020,03,15,NULL}}；
//可以在声明时定义和初始化结构体变量，也可以先声明后定义。结构体变量和普通变量一样，可以随意操作，包括取地址。
//结构体变量可以整体赋值或相同类型结构体变量相互赋值，但不能整体输入输出。
引用结构变量：结构体变量名.成员名        如stu1[1].num=108;
```

#### 指向结构体变量的指针

Student \*p=&student      //指针类型要用结构体类型，而不能用结构体变量。结构体变量名与数组名不同，不代表地址，需要加&。
//定义后，\*p等价与student，即student.num=(*p).num=p->num

```c++
结构体变量可以做函数参数，指向结构体变量的指针可以做函数参数，结构体变量的引用也可以做函数参数
    void print(Stu stu1);    
    void print(Stu  *);
    void print(Stu &);
```

#### 用new和delete运算符进行动态分配和撤销存储空间

C++提供new和delect来代替malloc和free，new和delete是运算符，不是函数，执行效率高。

 ```c++
new int;     //开辟一个存放整数类型的空间，并返回一个指向该存储空间的地址
new int(10)  //开辟一个存放整数类型的空间，指定其初值为10，并返回一个指向该存储空间的地址
int *p=new int(10) //开辟一个存放整数类型的空间，指定其初值为10，并返回一个指向该存储空间的地址给指针变量p
new char[5]  //开辟一个存放字符数组(包含5个元素)的的空间，并返回一个指向该存储空间的地址。用new分配数组空间不能指定初值
Stu *p=new Stu //动态开辟结构体类型空间，可以建立动态链表
//如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据返回指针的值判断分配空间是否成功
    
delete用法：delete 指针变量      //撤销指针变量所指向的变量的空间
           delete [] 指针变量   //撤销指针变量所指向的数组的空间
 ```

### 共用体类型

```c+
union Data 
{
int i;           
char n;
double f;
};
//共用体与结构体不同之处在于：系统为结构体中各成员分别分配存储单元，而共用体则是个成员共用一段存储单元。这样可以节省空间。
```

### 枚举类型

枚举(enumeration)类型的枚举变量只能用几种不同的取值。利用枚举变量可以把变量的值限制在一定范围内。

```c++
enum weekday{sun,mon,tue,wed,thu,fri,sat};   //声明枚举类型
weekday week1;    //定义枚举变量
//枚举元素按常量处理，故称枚举常量，不能对枚举元素赋值。
//枚举元素的值按顺序自动赋值为0，1，2...相当于设置了符号常量，可以进行数值运算，如for(int i=sun;i<=sat;i++)。
//可以输出枚举变量，但输出的是整数，如cout<<week1输出的是0
//不能把一个整数直接赋给一个枚举变量，枚举变量只能接受枚举类型数据，如week1=tue;要把整数赋给枚举变量，必须进行强制类型转换，如week1=weekday(2),相当于week1=tue;
```

### 用typedef声明新的类型名

声明一个新的类型名的方法：

1. 先按定义变量的方法写出定义语句，如int a[10]
2. 将变量名换成新的类型名，int NUM[10]
3. 在最前面加上typedef ，typedef int NUM[10]
4. 然后可以用新的类型名去定义变量，NUM a，a就是一个有是个元素的数组名，a[1]就是数组的第一个元素

```c++
typedef int INTEGER  
typedef struct    //这里不要写结构体类型名
{
    int month;
    int day;
    int year;
} DATA;   //声明DATA代表上面指定的结构体类型
typedef char * STRING  //声明STRING为字符指针类型
typedef int (*Pointer_to_Function)()   //声明Pointer_to_Function为指向函数的指针类型 
//用trpedef相当与给类型名取一个别名，并没有创造新的类型
//用typedef可以声明数组类型，字符串类型，使用比较方便
    如typedef int ARR[10]，ARR a,b,c。
```

#### 优点

* 开发程序时常用typedef声明不同的数据类型，把他们单独放在一个头文件中，可以用#include把它们包括到本文件中，就可以使用这些typedef类型名。这样方便编程，提供编程效率
* 使用typedef类型名去定义变量，可以在修改typedef声明时一次性修改全部变量的类型，有利于程序的通用和移植。

---



# C++面向对象编程(OOP-Object Oriented Programing)

## 1.类和对象基础

对于基于过程的结构化编程：程序=算法+数据结构
算法和数据结构是相互独立、分开设计的，基于过程的程序设计是以算法为主体。

而面向对象的编程设计关注的则是对象，认为数据结构和算法是一个紧密相连不可分割的整体，将算法和数据封装成一个对象：
                                            **对象=算法+数据结构（即一组数据和操作数据的一组函数）**
                                            **程序=对象+对象+对象+...消息(消息就是对对象的控制，在程序就是调用对象成员函数的一个命令语句)**

在基于过程的程序中，函数是构成程序的基本部分，程序面对的是一个个的函数。每个函数都是独立的，除了主函数只能被操作系统调用外，各函数之间可以相互调用，所有的数据都是公用的。设计者必须考虑程序中的每一个细节，确定时候什么调用什么函数操作什么数据，当程序规模较大、操作种类繁多时，就比较难以应付，所以基于过程的程序设计只适合编写简单小型的程序；
而在面向对象的程序设计中，程序的基本构成单位是类，除主函数外，其他的函数基本都被封装在类中，程序面对的是一个个类和对象，程序设计的主要工作是根据实际问题及需求设计、定义类和对象，以及考虑怎样向对象发送消息以使对象完成所需任务。通过类和对象，可以将复杂的问题拆分为一个个小部件小零件，并可以通过调用对象将各个零件组成一个有机的整体，简化了程序设计的过程，提高了工作效率。

面向对象的程序设计有四个主要特点：**抽象，封装，继承，多态**

**抽象**：客观世界中的任何事物都可以看成一个对象，具有静态特征即属性，动态特征即行为，对象由一组属性和行为构成。通过类可以表示同一类事物的共同特征即本质，可以很好的模拟客观世界。类是对对象的抽象，对象是类的具体实现。类是抽象的，不占用内存，而对象是具体的，占用储存空间。

**封装**：对象将有关数据和操作封装为一个整体，各个对象之间相互独立、互不干扰。并且对象中的某些部分对外屏蔽，外部无法得知对象内部的世界，而通过留下少量的接口接受外界的消息与外界进行联系。公用的函数就是对象的对外接口。这样可以实现信息屏蔽(information hiding)，有利于数据安全，防止无关人员了解和改动数据。

**继承**：子类(派生类)可以继承父类(基类)的数据和函数，实现了软件重用(software reusability)。开发软件时不必重新定义类，可以根据需要使用已有的类，减少了编程工作量。

**多态**(polymorphism)：由继承而产生的不同派生类，其对象对同一个消息会做出不同的响应，增加了程序的灵活性。

```c++
类的声明：
    class 类名       //类名首字母一般大写，对象名首字母一般小写
    {
        public:    //public和private成为成员访问限定符。
        公有的数据和成员函数；  //一般将需要被外界调用的成员函数指定为public，使之成为类对外的接口
        private:   //私有的成员不能在类外调用，不能在类外使用对象名.成员，只能被本类中的成员函数调用，但友员除外。     
        私有的数据和成员函数；//无论成员是私有的还是公有的，都可以在类外通过类的接口即公有函数调用和修改。
    }；//别忘了逗号
对象成员的引用：
        通过对象名和成员运算符 ：对象名.成员，如Student stu1;st1.name;
        通过指向对象的指针 ：                Student *p=&stu1;*p.name,p->name;
        通过对象的引用 ：                   Student &s=stu1;s.name;
        
//与结构体的区别：为了和C兼容，在C++中struct结构体类型也可以包含成员函数，可以用struct来声明一个类，用法和class一致。但是用struct声明的类，如果没有对其成员做public和private声明，则默认是public的，而class则默认是private的。
//内置(inline)成员函数：如果在类中定义的成员函数不包含循环等控制语句结构简单时，C++系统会自动将它们作为内置函数，把函数代码嵌入程序的调用点，不用执行一般函数的调用过程，可以减少函数调用过程中的时间开销；如果在类外定义成员函数，系统则不默认为内置函数，需要用inline做显式声明。但在类外定义inline函数，必须将类定义和成员函数的定义放在同一个源文件中，否则编译系统无法将函数代码拷贝嵌入到函数的调用点。但这样做不利于信息屏蔽，所以只有在成员函数规模较小且使用频繁时才会将其定义为内置函数。
//成员函数的存储方式：无论成员函数是公用的还是私有的，无论其是不是内置函数，其都不占用对象的存储空间，一个对象的存储空间只和其数据成员相关，与成员函数无关。成员函数是属于类的，不同对象的函数的代码都是相同的，无论调用的是哪一个对象的函数，调用的都是相同的函数代码。C++通过this指针来指向不同的对象，通过不同的对象调用成员函数时，this会指向不同的对象。
```

### 类的封装性和信息屏蔽

#### 公用接口和私有实现的分离

公用成员函数是类的对外接口，是用户使用类的公用接口(public interface)。
通过成员函数对数据成员的操作是类的功能的实现，实现的具体细节被封装在类中，用户看不到成员函数的源代码，而只能接触成员函数的目标代码，类的功能的实现细节对用户是屏蔽的，这种实现成为私有实现。通过**公用接口和私有实现的分离**，即可以实现类的功能，又实现了信息屏蔽。
当接口与实现分离时，只要类的接口(即调用的成员函数的形参的类型和个数不变)没有改变，对私有实现的修改不会引起其他额外的修改，有利于修改和扩充类的功能。且如果编译过程中发现类中的数据读写出错，不必检查整个程序，只须检查本类中访问这些数据的少量成员函数，这使得程序的设计、修改和升级更加方便。

#### 类声明和成员函数定义的分离

在面向对象的程序开发中，往往将类的声明(其中包含成员函数的声明)放在头文件中，使用该类时只需要把头文件包含进来即可，类声明头文件就是用户实现类库的公用接口，不必在程序在重复书写类的声明，减少了编程工作量，提高了编程效率。

类的成员函数的定义不放在类的声明中，而放在另一个源文件中。

一个C++程序包含3个部分：(1)类声明头文件(.h后缀)	(2)类实现文件(.cpp后缀)，包含类成员函数的定义	(3)类的使用文件(.cpp后缀)，即主函数文件。   
在程序中用#include指令包含类声明头文件，在编译时会把类的使用文件和类实现文件按多文件程序的规定组成一个统一的程序，经过编译连接后运行。 如果对成员函数的定义也放在头文件中，那么类的使用文件每进行一次编译都会对成员函数进行一次编译，会导致成员函数的多次编译，这是没有必要的。 所以一般将类的成员函数定义放在单独的文件中，只需要编译一次，将目标文件(.obj)保存起来，在需要时将其与程序的目标文件连接起来。

在实际工作中，往往将若干个功能类似的类声明集中在一起，形成各种类库。类库包含两个部分：(1)多个类声明的头文件 (2)各个类的经过编译的成员函数，即目标文件。用户只需要把类库放到自己的计算机系统(C++编译系统所在的子目录下)，在程序中用#include指令将所需的头文件包含进来，即可使用这些类。

开发商只需要给用户提供其需要的类库，即类的声明和目标文件，不提供源文件，用户看不到函数定义的源代码，更无法修改源代码，软件开发者的权益得到保护。

### 构造函数和析构函数

C++提供了构造函数(constructor)来进行对象的初始化，构造函数是一种特殊的成员函数，不需要用户来调用它，而是在建立对象时自动执行。构造函数的名字必须与类名一样，它不具有任何类型，不返回任何值。在建立对象(即定义对象)时会为对象开辟内存，会自动调用构造函数，把指定的初值送给相应的数据成员的存储单元中。构造函数提供了初始化多个对象的统一方法，而不必对多个对象逐个显式的初始化。

析构函数(destructor)与构造函数作用相反，当对象的生命周期结束时，程序会自动调用析构函数。析构函数没有函数类型，不返回任何值，也没有函数参数。析构函数的作用不是删除对象，而是在撤销对象占用的内存单元之前完成一系列清理工作，如删除类中定义的指针。一个类可以有多个构造函数，但只能有一个析构函数。

一般情况下，对象的建立相对于一个栈，先进后出，调用析构函数的次序与调用构造函数的次序相反，先构造的后析构，后构造的先析构。

```c++
class Time        
{
    public:      //构造函数和析构函数都在public下面定义
    Time()       //在类内定义无参的构造函数。
    {
        hour=0;
        minute=0;
    }
    Time(int a,int b)；                      //在类内声明带参数的构造函数，还需要在类声明下面进行定义
    Time(int a,int b):hour(a),minute(b){}   //可以用参数化列表在类内直接定义带参数的构造函数
    Time(int a=10,int b=1)；      
    //在类内声明带默认参数的构造函数。还需要在类下面定义构造函数，但可以不再写默认参数。但需要注意，全部参数都指定了默认值的构造函数也属于默认构造函数，而类只能有一个默认构造函数，因此类不要同时定义无参的构造函数和全部参数都指定了默认值的构造函数。
        
    ~Time()              //析构函数一般直接在类内定义
    {
        cout<<"Destructor called"<<endl;
    }
    private:
    int hour;//不可以在类内初始化数据成员，如int hour=0;因为类并不是一个实体，不占用内存，无法容纳数据，定义变量时才会开辟空间。
    int minute;
};
//在类外定义成员函数，必须先在类内进行声明，且函数的定义必须放在类声明的后面。
//可以为一个类定义多个不同的构造函数(函数名字相同，而参数的个数或参数的类型不同)，这叫做构造函数的重载。
    Time::Time()  //在类外定义构造函数
    {             //这是一个无参构造函数，属于默认构造函数，即在程序中用Time tim1建立对象时会调用无参构造函数，如果未定义无参构                     造函数，系统会提供一个默认的构造函数。注意不要写成Time tim1();
        hour=0;
        minute=0;
    }
    Time::Time(int a,int b)  //带参数的构造函数
    {
        hour=a;
        minute=b;
    }

int main()
{
    Time tim1;           //建立对象时调用默认构造函数，不要用Time tim1();
    Time tim1(20,10);    //建立对象的同时指定数据成员的初值
    Time times[50]={
        Time(1,1),Time(2,2),Time(10,10)
    }
  //这是一个对象数组，可以在建立对象数组时，分别调用构造函数，对每个成员进行初始化。times[2].hour,可以像普通数组元素一样使用对象
}

//对象的赋值：
Time tim1,tim2(10,20);
tim1=tim2;
将一个已有的对象赋值给另一个已有的对象，这是通过成员复制(memberwise copy)来完成的,即将一个对象的成员值一一复制到另一个对象的对应成员的存储空间，对象的赋值只对其中的数据成员赋值，而不对成员函数赋值。注意数据成员中不能包括动态分配的数据，否则赋值时可能出现严重后果。
//复制构造函数：
    类名 对象名(已有对象名) //用一个已有的对象赋值新生成一个完全一样的对象。
    如Time tim2(tim1)或Time tim2=tim1；
    在建立对象时，调用一个特殊的构造函数——复制构造函数(copy constructor),原型为Time::Time(const Time&tim1)，复制构造函数也是构造函数，它只有一个参数，就是本类的对象，并且采用对象的引用方式。用户没有定义的话，编译系统会自动生成一个默认的复制构造函数，其作用只是简单地复制对象的每个数据成员。
    注意：对象的赋值是对一个已经存在的对象赋值，因此必须先定义被赋值的对象。而对象的复制则是从无到有建立一个新对象，使之与已有对象完全相同。
```

### 类模板

类模板是对类的抽象，类是类模板的实例。利用类模板可以建立含各种数据类型的类，使类的使用不受限于数据类型。

```c++
template<class numtype1,class numtype2>  //可以定义一个或多个类型参数名
    class Time
    {
        public:
        Time(numtype1 a,numtype2 b);
        int ss()        //类模板中可以有具体的类型名。利用虚拟类型名只是会在传递具体参数类型时，用具体参数类型替换虚拟类型。
        {
            return hour*minute;
        }
        void dispaly();
        private:
        numtype1 hour;
        numtype2 minute;
    }；
    template<class numtype1,class numtype2>
    void Time<numtype1,numtype2>::diaplay()
    {
        cout<<hour<<minute;  //在类模板体外定义成员函数时需要把template虚拟参数表再写一遍，并加上类名<虚拟类型参数表>
    }
    int main()
    {
        Time<int,flaot> tim1(10,20); //用类模板定义对象。
    }
```

### 对象指针

#### 指向对象的指针:

对象空间的起始地址就是对象的指针。

```c++
 Time *p;Time tim1;p=&tim1;             可以用(*p).hour;p->hour;p->display();访问对象的公有成员
     
对象的动态建立与释放：
     用类名 *指针变量名=new 类名(初始化参数) //创建并初始化匿名对象，如Time *p=new Time(10,20);
     delete p;                    //撤销p指向的内存单元，在释放匿名对象的内存单元之前，会自动调用析构函数，完成有关善后清理工作
```

#### 指向对象成员的指针：

指向对象公用数据成员的指针：

```c++
int *p=&tim1.hour;  //对象公用数据成员与普通变量类似
```

指向对象公用成员函数的指针：

```c++
形式为： 返回值类型 (类名::*指针变量名)(参数列表)，如int (Time::*p)(int ,int);
使指针变量指向公用成员函数形式为： 指针变量名=&类名::成员函数名，如p=&Time::display,不用加()，注意函数的入口地址为&类名::成员函数名，而不是对象名.成员函数名
调用公用函数：对象名.*指针变量名，如tim1.*p(5，10),*p与函数名等价，与普通函数不一样
```

#### this指针

this指针是指向类对象的指针，它的值是当前被调用的成员函数所在对象的起始地址。在程序中用对象名.成员函数调用成员函数时，会将对象的起始地址传递给this指针，this指针是隐式使用的，它会被作为参数被传递给成员函数这样成员函数就可以通过this指针确定它要去调用的是哪一个对象的数据成员。

```c++
如成员函数的定义为void display()
{
    cout<<hour<<minute<<endl;
}
实际上为void display(Time *this)
{
    cout<<this->hour<<this->minute<<endl;//即cout<<(*this).hour<<(*this).minute<<endl;
}
调用tim1.display()实际上为tim1.display(&tim1);
```

### 共有数据的保护

对对象的数据成员的修改做一定的限制，用于保护对象的数据成员。

#### 常对象

```c++
Time const tim1(10,20)//建立常对象时必须赋初值，在对象的生命周期中，对象的所有数据成员的值都不能被修改
    如果一个对象被声明为常对象，则在程序中通过该对象只能调用其常成员函数(但不能修改数据成员的值)，而不能调用其非常成员函数
    对于必须变化的特殊数据成员，可以用mutable来声明，如mutable int count,则可以用常成员函数来修改其值。
```

#### 常数据成员

const int hour;//用const声明某些数据成员，保证其值不会被改变，但既可以用非const也可以用const成员函数访问它

注意：只能通过构造函数的参数化列表对常数据成员进行初始化，如Time::Time(int h):hour(h){}，而不能用带普通的构造函数或其他成员函数对其初始化，因为任何声明为const的变量在建立后都不能再被赋值。常对象相对于所有数据成员都被声明为const的的对象，因此常对象只能用参数初始化列表进行初始化。

#### 常成员函数

void Time::get_time() const;    //常成员函数，不能修改任何数据成员的值，但既可以引用const数据成员，也可以引用非const数据成员
常成员函数不能调用另一个非const成员函数。

小结：无论数据成员或者成员函数有没有用const声明，成员函数都可以调用任何数据成员。

#### 指向对象的常指针

```c++
形式：类名 *const 指针变量名；如Time *const p=&tim1;指针变量的指向不能改变，即指针变量的值不变，但可以通过其改变指向的对象的值。
```

#### 指向常对象的指针

```c++
形式：const 类名 *指针变量名；如const Time *p=&tim1;
无法通过指针变量来修改其指向的对象的值，但指针变量的指向可以改变，且对象可以通过其他方式改变。
```

重要：指向常对象的指针变量可以指向const对象，也可以指向非const对象(但仍不能通过指向常对象的指针变量来修改它)；如果一个对象被声明为const对象，则只能用指向常对象的指针变量指向它，即指向非const对象的指针变量只能指向非const对象，不能指向const对象。

#### 对象的常引用

```c++
void Time::get_time(const Time &tim);在调用过程中不能修改实参的值
```

指向常对象的指针和对象的常引用经常用作函数参数，在调用函数时不会开辟内存建立实参的拷贝，且保证实参在调用过程中不会被改变。

### 静态成员

静态数据成员用于在同一个类的多个对象之间实现数据共享。利用静态数据成员，各对象之间的数据有了沟通的渠道，实现数据共享，这样可以节省空间，提高效率。

```c++
class Time
{
    public:
    void diaplay();
    static int day;	  //将公用数据成员声明成静态数据成员
    static void display();  //声明静态成员函数。
    private:
    static int hour; //将私有数据成员声明成静态数据成员。静态数据成员是属于类的，在所有对象外单独开辟空间，不占用对象的存储空间，所有的对象都可以通过对象名.静态成员数据名来引用静态数据成员，且改变它的值，则在各对象中的值都同时改变了。
    int minute;
};
int Time::hour=10;//静态成员数据只能在类外进行初始化，不能用参数初始化列表对其进行初始化
//静态数据成员在声明类时就会分配空间，即使没定义对象，也可以通过类名::引用，静态数据成员在类的作用域内一直存在，不随对象的建立而分配空间，也不随对象的撤销而释放。
void Time::diaplay()
{
    cout<<day<<hour<<endl;//不能直接引用minute，但可以指定对象来引用，如cout<<tim2.hour;
}
//静态成员函数和非静态成员函数的区别：静态成员函数没有this指针，不能通过默认访问的方式直接引用类中的非静态成员，因为不知道该去找哪个对象。静态成员函数主要用来访问本类的静态数据成员，可以直接引用。
//非静态成员函数既可以引用非静态成员也可以引用静态成员，而静态成员函数只能引用静态成员而不能引用非静态成员。
//用static声明静态数据成员或静态成员函数并影响成员的public与private属性。
int main()
{
    Time tim1;
    tim1.day=1;
    Time::day=1;	//公用的静态数据成员既可以用对象名.引用，也可以用类名::引用
    tim1.diaplay(); //公用的成员函数既可以用对象名.引用，也可以用类名::引用
    Time::diaplay();
}
```

### 友员

在类声明中将普通函数，其他类的成员函数或者其他类声明为友员，使不属于本类的函数可以访问本类的私有成员。

面向对象的程序设计的一个基本原则是封装性和信息屏蔽，而友员却可以访问其他类的私有成员，也是对封装原则的一个小小的破坏。但是却能有助于数据共享，提高程序的效率，在实际使用在要在数据共享和信息屏蔽之间找一个恰当的平衡点。

```c++
class Date;   //由于下面Time中出现了Date,需要对其做提前引用声明,只包含类名，不包含类体
class Time
{
    public:
    friend void s1(Time&);    //将普通函数声明为友员函数
    friend void Date::s2(Time&); //将其他类的函数成员声明为友元函数
    friend Display;   //声明友元类。友元类的所有成员函数都是其友元函数。友员的关系是单向的不是双向的，且友员的关系不能传递。
    private:
    int hour;
    int minute;
};
class Date
{
    public:
    void s2(Time&);
    private:
    int year;
    int month;
    int day;
};
void s1(Time&tim1)
{
    cout<<tim1.hour<<tim1.minute<<endl;  //不能直接引用，必须加上对象名
}
void Date::s2(Time&tim1)
{
    cout<<year<<month<<day; //可以直接引用本类在的数据成员
    cout<<tim1.hour<<tim1.minute<<endl;  //不能直接引用其他类的私有数据，必须加上对象名
}
int main()
{
    Time tim1(10,20);
    s1(tim1);
    Date dat1(1,1,1);
    dat1.s2(tim1);
}
```

## 2.运算符重载

运算符重载(operator overloading)是定义一个重载运算符的函数，使指定的运算符不仅能实现原有的功能，还能够实现在函数中指定的新功能。运算符重载的本质是函数的重载。

利用运算符重载，可以让类对象使用现有的运算符而不必重新定义一批新的运算符，扩大了C++已有运算符的使用范围，使程序易于编写、阅读和维护。

运算符重载的一般格式为：

​											函数类型  operator 运算符名(形参表)
​													{对运算符的重载处理} 

C++中绝大部分运算符都允许重载，但是不能重载的运算符有5个：
.(成员访问运算符)	::(域域运算符)	*(成员指针访问运算符)	sizeof(长度运算符)	?:(条件运算符)

重载运算符不改变运算符的运算对象的个数、优先级别、结合性，且不能有默认的参数。重载的运算符必须和用户自定义的结构体类型或类类型一起使用，其参数不能全是C++的标准类型，防止篡改用于标准类型数据的运算符的性质。

```c++
class Complex
{
    public:
    Complex(){real=0;imag=0;}
    Complex(int r,int i){real=r;imag=i;}
    Complex complex_add(Complex &);
    Complex operator +(Complex &);//把运算符重载函数作为类的成员函数
    friend Complex operator +(Complex&c1,complex&c2);//把运算符重载函数作为类的友员函数
    friend Complex operator +(int&num,complex&c2);
    friend Complex operator +(complex&c2,int&num);//对于双目运算符，交换律不适用，需要重载两次
    friend bool operator >(complex&c1,complex&c2);
    
    Complex operator ++();//重载单目运算符，没有参数。为前置单目运算符重载函数。
    Complex operator ++(int);//加一个int表明为后置单目运算符重载函数。
    
    friend ostream& operator <<(ostream&,Complex &);//重载流插入运算符
    friend istream& operator >>(istream&,Complex &);//重载流提取运算符
    
    Complex(int r) {real=r;imag=0;}//转换构造函数。转换构造函数只能有一个参数，参数是需要转换的类型，可以是基本类型，也可以是类，用于将该参数转换为类对象。在程序中可以用类名(指定类型的数据)进行显示强制类型转换。在已定义了相应的转换构造函数情况下，用友员函数重载双目运算符(如+)，可以使交换律可用，如Complex c3=2+c1与Complex c3=2+c1等价，都会将2隐式转换成Complex(2)对象。
    operator int() {return real;}//类型转换函数。类型转换函数的作用是将一个类的对象转换成另一种类型的数据。形式为:operator 类型名(){实现转换的语句，即返回类型为类型名的一个参数}。无函数类型，其返回值类型由指定的类型名确定，只能作为类的成员函数。类型转换函数也称为类型转换运算符重载函数。定义了类型转换函数，则不需要再对各种运算符进行重载，因为类型转换函数可以自动的将类对象转换为基本类型。如int k=c1+2,会隐式的将c1转换为int数据。char c=c1+'a',也会隐式地将c1转换为int数据，再与char类型相加。如同时也定义了重载+的函数，则编译系统不知道怎么解释c1+2，实现二义性。
//转换构造函数和类型转换函数有一个共同的功能：当需要的时候，编译系统会自动调用这些函数，建立一个无名的临时对象或临时变量。   

    private:
    int real;
    int imag;
};
//重载运算符只能把一个运算符用于指定的类，并不是用一个运算符重载函数就可以适用所有的类。
Complex Complex::complex_add(Complex&c2)   //返回一个Complex对象的成员函数
{
    Complex c;
    c.real=real+c2.real;
    c.imag=imag+c2.imag;
    return c;
}
Complex Complex::operator +(Complex &c2)  //定义重载运算符函数。
{
    Complex c;
    c.real=real+c2.real;
    c.iamg=imag+c2.imag;
    return c;
    //以上可以简写为return  Complex(real+c2.real,iamg+c2.iamg);
}
//将运算符重载函数声明为类的成员函数，它可以通过this指针自由地访问本类中的数据，可以少写一个形参。对于双目运算符，要求运算符左侧的操作数必须是一个类对象，且返回值类型必须是本类类型(否则定义这个运算符重载没有意义)。
//而将运算符重载函数作为类的友员函数，是一个普通的函数，可以自由的指定运算符操作数的类型与返回值类型。
Complex operator +(Complex&c1,Complex&c2)
{
    return  Complex(c1.real+c2.real,c1.iamg+c2.iamg)
}
Complex operator +(int&num,Complex&c2)
{
    return  Complex(num+c2.real,c2.iamg);
}
bool operator >(complex&c1,complex&c2)
{
    if(c1.real>c2.real) return true;
    else return false;
}
bool compare(complex&c1,complex&c2)//这是一个普通的函数，只是形参是类对象，但不是类的友元函数，只能访问类对象的公用成员
{
    if(operator >(c1,c2)) return true;   //调用运算符重载函数operator >(c1,c2)
    else return false;
}
Complex Complex::operator ++()
{
    ++real;
    return *this;//先执行操作，再返回当前对象。
}
Complex Complex::operator ++(int)
{
    Complex temp(*this);
    ++real;
    return temp;//先返回当前对象，再对当前对象执行一定的操作。
}
//对象不能直接用<<或>>输入输出，必须进行运算符重载，且只能将运算符重载函数定义为友元函数
ostream& operator <<(ostream& outputname,Complex &c)
{//outputname是ostream类的对象，名字可以随便起
    outputname<<c.real<<c.imag<<endl;
    return outputname;//最后必须返回一个ostream类对象，用于连续插入
}
istream& operator >>(istream& inputname,Complex &c)
{//iutputname是istream类的对象，名字可以随便起
    inputname>>c.real>>c.imag;
    return inputname;//最后必须返回一个istream类对象，用于连续提取
}
int main()
{
    Complex c1(1,2),c2(3,4),c3;
    c3=c1.complex_add(c2);
    c3=c1+c2;//相当于调用c1.operator +(c2);
    c3=2+c1;//相对于调用operator +(2,c1);
    c3=c1+2;//相对于调用operator +(c1,2);
    c3=++c1;//调用前置单目运算符重载函数
    c3=c1++;//调用后置单目运算符重载函数
    cout<<c3<<c2;//调用operator <<(cout,c3),cout传递给outputname，返回一个cout对象。cout是一个ostream类对象。
    //相对于(cout<<c3)<<c2，即cout(新值)<<c2.
    //<<运算符重载函数的第一个参数和函数类型都必须是ostream类型的引用，就是为了返回cout的当前值以便连续输出。
    cin>>c3>>c2;//调用operator >>(cin,c3),cin传递给inputname,返回一个cin对象。cin是一个istream类对象
}
```

默认规则：

1. 赋值运算符=,下标运算符[],函数调用运算符(),成员运算符->必须作为成员函数。
2. 流插入运算符<<和流提取运算符>>，类型转换运算符只能作为友元函数。
3. 一般将单目运算符与复合运算符(+=,++,/,!=,<<=,>>=,^=)作为成员函数。
4. 一般将双目运算(+,-,<,>,==)符作为友员函数。

## 3.继承与派生

面向对象编程强调软件的重用性(software reusability)，C++提供了类的继承机制，解决了软件重用的问题。

一个新类从已有类获得其特性，称为类的继承(inheritance)。从已有类产生一个新类，称为类的派生。
一个派生类只从一个基类继承，称为单继承(single inheritance)；一个派生类有两个或多个基类，称为多重继承(multiple inheritanc)。
派生类是基类的具体化，基类是派生类的抽象。
派生类要继承就会继承基类的全部成员(但不继承基类的构造函数和析构函数，需要在派生类中自己定义)，不能只继承部分成员。

派生类的形式为:

```c++
class 派生类名：[继承方式] 基类名            //可以不写继承方式，默认为私有继承
{
    派生类中新增的成员；
}//派生类中包含三类成员：从基类接收的成员，从基类接收但重写了的成员，新增的成员
```



#### 重写/覆盖与重载：

重写/覆盖：在派生类重新声明一个与基类成员函数同名的函数，且参数的类型与个数都相同，则派生类的函数会覆盖从基类继承来的同名函数，这叫做重写或覆盖。用派生类对象名.函数名()会调用重写后的函数。但被重写的成员函数或数据成员仍然是存在的，可以在派生类中通过基类名::基类成员函数名()或基类名::基类数据成员名显式调用。

重载：函数名相同，而参数的类型与个数至少有一个不同。用派生类对象名.函数名()调用同名函数是会根据实参的类型和个数确定调用的是基类的还是派生类的函数。

#### 派生类成员的访问属性

派生类的成员函数可以任意调用派生类的成员(无论是public还是private，private只是限制在类外不能通过对象名.成员名来调用)，基类的成员函数可以任意调用基类的成员，而基类的成员函数不能调用派生类的成员，派生类的成员函数是否可以调用基类的成员需要根据继承方式确定。

| 在基类的访问属性 |      继承方式       | 在派生类在的访问属性 |
| :--------------: | :-----------------: | :------------------: |
|      public      |  public(公用继承)   |        public        |
|     private      |       public        |       不可访问       |
|    protected     |       public        |      protected       |
|      public      |  private(私有继承)  |       private        |
|     private      |       private       |       不可访问       |
|    protected     |       private       |       private        |
|      public      | protected(保护继承) |      protected       |
|     private      |      protected      |       不可访问       |
|    protected     |      protected      |      protected       |

不可访问指的是在派生类中不能直接访问基类的私有成员，但可以通过调用派生类中可以调用的基类成员函数来间接调用甚至修改私有数据成员。无论哪一种继承方式，在派生类中都不能访问基类的私有成员。
protected指的是受保护的成员不能在类外通过对象名.成员名被显式调用，但可以在类中被成员函数任意调用。

#### 派生类的构造函数和析构函数

基类的构造函数和析构函数不能继承，但可以被调用，需要重新定义派生类的构造函数和析构函数。一般会在执行派生类的构造函数时调用基类的构造函数，使派生类的数据成员和从基类继承的数据成员同时被初始化。

建立一个派生类对象时，派生类的构造函数先调用基类构造函数对继承来的数据成员进行初始化，在对其子对象进行初始化，再执行派生类构造函数本身的函数体。
在派生类对象释放时，派生类的析构函数会调用基类的构造函数，先执行派生类的析构函数，在执行子对象的析构函数，再执行其基类的析构函数。

```c++
class Stu
{
    public:
    Stu(int n,string nam,char s)
    {
        num=n;
        name=nam;
        sex=s;
    }
    ~Stu(){};
    protected://private数据成员不能被派生类初始化
    int num;
    string name;
    char sex;
};

class Stu1: public Stu
{
    public:
    Stu1(int n,string nam,char s,int a,string ad):Stu(n,nam,s)
    {
        age=s;
        addr=ad;
    }
    //可以用参数初始化表，写成Stu1(int n,string nam,char s,int a,string ad):Stu(n,nam,s),age(a),addr(ad){}
    //可以先声明,在类体内只需要写Stu1(int n,string nam,char s,int a,string ad);然后在类体下面定义
     Stu1(int n,string nam,char s):Stu(n,nam,s){} //参数表中只有要送给基类构造函数和子对象的参数，只初始化基类的构造函数和子对象，不对派生类新增成员做任何操作，在实际工作中常见这种做法。
    
  Stu1(int n,string nam,char s,int a,string ad,int nam2,char s2):Stu(n,nam,s),stu1(n,nam2,s2),age(a),addr(ad){}
//参数的顺序和数目可以按需传递，形参和实参是按照名字对应的，一个参数可以同时传递给基类和子对象。
    归纳起来，定义派生类的构造函数的一般形式为：
        派生类构造函数名(总参数表):基类构造函数名(参数表)，子对象名(参数表)
    {派生类中新增数据成员的初始语句}
    
    ~Stu(){};
    protected:
    int age;
    string addr;
    Stu stu1;  //类的数据成员可以是对象，即对象中的对象，称为子对象(subobject)。
    Teacher tea;//子对象可以不是基类类型的。这称为类的组合(composition)。
    //通过组合建立了数据类与组合类(或称复合类)的关系，它们之间不是“是”的关系，而是"有"的关系。继承是纵向的，组合是横向的。通过这种方式，可以有效地组合和利用现有的类，减少了代码工作量。
};
class Stu2: public Stu1   //多层派生
{
    public:
    Stu2(int n,string nam,char s,int a,string ad,int w):Stu1(n,nam,s,a,ad),wage(w){}
    //多层派生时，只需要在派生类的构造函数调用其直接基类的构造函数即可，不能一直往上。
    private:
    int wage;
};

//多重继承
class D:public B,private C      //B,C继承自A
{
    public:
    派生类构造函数名(总参数表):基类B构造函数(参数表)，基类C构造函数(参数表)
    {       //多重派生类的构造函数
        派生类中新增的数据成员的初始化语句
    }
/*多重派生的二义性问题：
由于多重继承，可能导致D中有一些重名的成员，这些数据成员不会相互抵消而都会占用派生类对象的存储空间，引用这些重名成员时会产生二义性问题(ambiguous)。
解决方法是显式指定数据成员所属的类，在派生类内用基类名::数据成员名调用(如C::c)，在派生类体外通过派生类对象名.基类名::数据成员名(如d.B::b)调用。
注意：派生类的数据成员只包括基类的数据成员和自己新增的数据成员，不包括基类的基类的数据成员，即基类的基类的数据成员不会占用派生类的空间，因为基类的基类的成员都已经被基类继承，派生类中不可以出现基类的基类名，如在派生类中不可以这样A::a。但如果D直接继承了A(如class D:public B,private C,private A)，则可以用A::a。

虚基类(virtual base class)：
如D继承B和C，二B和C都继承自A，则A的成员会在D中保留两份。会造成二义性，且占用一些不必要的空间。
虚基类使得当基类通过多条派生路径被派生到一个派生类继承时，该派生类只继承该基类一次，也就是说在继承间接共同基类时只保留一份成员。
class A
{};
class B:virtual public A  //虚基类不是在声明基类的时候声明的，而是在声明间接派生类时声明的，因为一个基类可以可以在声明一个派生类时作为虚基类，也可以在声明另一个派生类时不作为虚基类。
{};
class C:viitual private A
{};
class D:public B,private C,protected A
{
	public:
	D(总参数表):A(参数表)，B(参数表)，C参数表)  
	{D中新增的数据成员的初始化语句}
	//在最后的派生类中，不仅要对其直接基类进行初始化，还需要对虚基类初始化。C++编译系统只执行最后的派生类对虚基类构造函数的调用，二忽略基类的其他派生类(如B和C)对虚基类的构造函数的调用，也就保证了虚基类的数据成员不会被多次初始化。
};
//不提倡在程序中使用多重继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多重继承，如能用单一继承解决的问题就不要使用多重继承。也是这个原因，有些面向对象的程序设计语言(如JAVA,Smalltalk)并不支持多重继承。
*/
};
```

#### 派生类和基类的转换

派生类对象可以给基类对象赋值：如Stu stu=stu1;但子对象不能给基类对象赋值。同一个基类的不同派生类之间也不能相互赋值。
派生类对象可以替代基类的对象给基类对象的引用进行赋值或初始化。
如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象。
即基类和派生类之间的赋值只能是多到少，即派生类->基类，将派生类中继承而来的数据成员复制给基类对象的对应的数据成员。

派生类对象的地址可以赋给指向基类对象的指针变量，也就是说，指向基类对象的指针变量可以指向派生类对象。
但需要注意：通过指向基类对象的指针，只能访问派生类中的基类成员，不能访问派生类中增加的成员。调用派生类中的被重写的同名函数时，调用的是基类的函数。

#### 继承的意义

继承解决了软件重用的问题。

在实际工作中，类库中的声明放在头文件中，而基类的定义放在源文件中，对基类进行编译得到目标文件，然后与头文件一起提供给用户使用，用户可以根据自己的需要去继承基类。由于不提供基类的源码，基类的安全性的得到保证，且基类是单独编译的，在程序中每次编译只需要对派生类进行编译，大大提高了调试程序的效率。如果在必要时修改了基类，只要基类的公用接口不变，派生类不必做代码修改，但基类和派生类都需要重新编译。

实际上，许多基类并不是从已有程序中选取出来的，没有独立的功能，而是专门作为基类设计的，只是一个框架，或者说抽象类。人们根据需要设计一批能适用于不同用途的通用基类，目的是建立通用的数据结构，以便用户能在此基础上添加各种功能建立各种功能的派生类。

## 4.多态性与虚函数



# C++泛型编程(generic programing)

## 2.标准模板库STL

STL是C++标准的组成部分，不是面向对象编程，而是一种不同的编程模式——泛型编程。

STL提供一组表示容器/迭代器/函数对象和算法的模板，能够构造各种容器(包括数组/队列/链表等)和执行各种操作(包括搜索/排序和随机排列等)。

容器是一个与数组类似的单元，可以动态的存储若干个类型一样的值。

算法是完成特定任务(如对数组进行排序和在链表中查询特定的值)的处方。

函数对象是类似于函数的对象，可以是类对象或函数指针(包括函数名,因为函数名被用作指针)。

### 模板类vector(矢量)

是一种容器类，可以用来创建动态数组，使用动态内存分配，在使用时要#include <vector>

创建一维动态矢量：vector<int>  Nums(n)，矢量中含有n个int 变量，Nums就是一个对象，Nums[2]表示矢量中的第3个元素。

创建二维动态矢量：vector<vector<int>> Nums，默认为0个元素。Nums\[2][3]，可以像数组一样用[]随机访问元素。

所有的STL容器都提供了一些基本，vector模板类也可以使用，如:

```c++
Nums[2].size()   //返回Nums[2]容器中的元素个数
Nums.size()      //返回Nums容器中总的元素个数
Nums[2].swap(Nums[3])  //交换两个容器的内容
Nums.begin()    //返回一个指向容器第一个元素的迭代器
Nums.end()      //返回一个表示超过容器尾的迭代器
Nums[1].empty()  //若Num[1]为空则返回true
vector<int> NewNums(Nums)  //可以用一个已有的矢量去初始化一个新矢量
Nums.push_back(a) //在矢量末尾插入一个元素
Nums.erase(Nums.begin(),Nums.begin()+2)//删除Nums矢量第一个和第二个元素
Nums.insert(a)//在头部插入一个元素
Nums.insert(Nums.end(),Other.begin()+1,Other.end())//将Other矢量的第2个到最后一个元素插到Nums的末尾
Nums.insert(Nums.begin(),Other.begin(),Other.begin()+2)//将Other矢量的第1个到第2个元素插到Nums的头部
```

#### 迭代器

迭代器是一个广义指针，指向容器，能够用来遍历容器的对象，还可以通过解除引用算符*来引用容器，让STL能够为各种不同的容器类(包括那些简单指针无法处理的类)提供统一的接口。

```
声明迭代器:vector<int>::iterator p;//每一个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为iterator的typedef
for(p=Nums[1].begin();p!=Nums[1].end();p++)
cout<<*p;
```

#### 可对矢量执行的其他操作

STL从更广泛的角度定义了一些非成员函数，可用于操作所有容器类，但并不是容器的成员函数。

```c++
for(p=Nums[1].begin();p!=Nums[1].end();p++)
Show(*p);
等价于：for_each(Nums.begin(),Nums.end(),Show)//前两个是定义容器中区间的迭代器,最后一个是指向函数的指针，即函数对象

Random_shuffle(Nums.begin(),Nums.end())//Random_shuffle函数接受两个指定区间的迭代器参数，并随即排列该区间中的元素
    
sort(Nums.begin(),Nums.end())
//Sort函数可以对容器指定区间的元素进行排序。如果容器元素是用户自定义的对象，需要先对容器元素类型重载运算符<，如果是基类型则不必。
sort(Nums.begin(),Nums.end(),WorseThan)//可以按照WorseThan定义的比较方法对容器中的元素进行排序
```

