# 排序法总结

![常用排序法总结](D:\My_Program_data\Cpp-exercise\排序法汇总\常用排序法总结.png)

### 几种排序法比较：

从待排序记录的个数来看，个数越小，采用简单排序越合适，记录较大的话需要采用改进排序方法。

从平均情况看，快速排序/归并排序和堆排序胜过希尔排序，并远胜3种简单排序；

从最好情况看，反而冒泡排序和直接插入排序要好一点，也就是说，如果你的待排序列基本有序就不必考虑4种改进排序算法。

从最差情况看，堆排序和归并排序又强过快速排序。

从稳定性看，归并排序独占鳌头，对于非常在乎稳定性的序列，应该选择归并排序。

而对于记录的关键字本身信息比较大，移动记录的花费时间比较长，简单选择排序则变得很有优势，它对记录的移动很少。

总的来说，经过优化的快速排序是性能最好的排序算法，但是不同的场合我们也应该考虑使用其他更合适的算法。

## 比较排序和非比较排序

   常见的排序算法都是比较排序，非比较排序包括计数排序、桶排序和基数排序，非比较排序对数据有要求，因为数据本身包含了定位特征，所有才能不通过比较来确定元素的位置。

   比较排序的时间复杂度通常为O(n2)或者O(nlogn)，比较排序的时间复杂度下界就是O(nlogn)，而非比较排序的时间复杂度可以达到O(n)，但是都需要额外的空间开销。

   比较排序时间复杂度为O(nlogn)的证明：

   a1,a2,a3……an序列的所有排序有n!种，所以满足要求的排序a1',a2',a3'……an'（其中a1'<=a2'<=a3'……<=an'）的概率为1/n!。基于输入元素的比较排序，每一次比较的返回不是0就是1，这恰好可以作为决策树的一个决策将一个事件分成两个分支。比如冒泡排序时通过比较a1和a2两个数的大小可以把序列分成a1,a2……an与a2,a1……an（气泡a2上升一个身位）两种不同的结果，因此比较排序也可以构造决策树。根节点代表原始序列a1,a2,a3……an，所有叶子节点都是这个序列的重排（共有n!个，其中有一个就是我们排序的结果a1',a2',a3'……an'）。如果每次比较的结果都是等概率的话（恰好划分为概率空间相等的两个事件），那么二叉树就是高度平衡的，深度至少是log(n!)。

   又因为 1. n! < n^n^ ,两边取对数就得到log(n!)<nlog(n)，所以log(n!) = O(nlogn).

​               2. n!=n(n-1)(n-2)(n-3)…1 > (n/2)^(n/2) 两边取对数得到 log(n!) > (n/2)log(n/2) = Ω(nlogn)，所以 log(n!) = Ω(nlogn)。

   因此log(n!)的增长速度与 nlogn 相同,即 log(n!)=Θ(nlogn)，这就是通用排序算法的最低时间复杂度O(nlogn)的依据。

## 1.冒泡排序法

是一种交换排序，基本思想为：两两比较相邻记录的关键字，如果反序则交换，直到没有反序记录为止。类似于冒泡，它通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，较小的数据上升。冒泡排序是最慢的排序算法。在实际运用中它是效率最低的算法。

有两种优化思路：

优化一：如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个Flag做标记，默认为false，如果发生交互则置为true，每轮结束时检测Flag，如果为true则继续，如果为false则返回。

优化二：某一轮结束位置为j，但是这一轮的最后一次交换发生在lastSwap的位置，则lastSwap到j之间是排好序的，下一轮的结束点就不必是j--了，而直接到lastSwap即可。

## 2.简单选择排序

遍历数组，遍历到i时，a0,a1...ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。

无论好坏情况，它都需要进行n*(n-1)/2次比较，但是它最大的特点就是交换移动数据次数比较少，最好为0次,最差为(n-1)次，这样节约了交换数据的时间。总的来说，简单选择排序性能略优于冒泡排序。

## 3.直接插入排序

遍历数组，遍历到i时，a0,a1...ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。可见相等元素比较是，原来靠后的还是拍在后边，所以插入排序是稳定的。

当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。

直接插入排序性能比冒泡排序和简单选择排序要稍好一点。

## 4.希尔排序(Shell sort)

希尔排序是D.L.Shell于1959年提出的一种排序算法，是对插入排序的优化，基于以下两个认识：1. 数据量较小时插入排序速度较快，因为n和n^2^差距很小；2. 数据基本有序时插入排序效率很高，因为比较和移动的数据量少。

   因此，希尔排序的基本思想是将需要排序的序列以某个增量的距离划分成为若干个较小的子序列，对子序列进行插入排序，通过插入排序能够使得原来序列成为基本有序。这样通过对较小的序列进行插入排序，然后对基本有序的数列再进行下一轮进行插入排序，能够提高插入排序算法的效率。

希尔排序的时间复杂度和增量的选择策略有关，但由于数据比较是跳跃式的，所以希尔排序不稳定性。

## 5.堆排序(Heap sort)

堆排序是利用堆进行排序的一种算法。由Floyd和Williams在1964年发明。堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆；

堆排序的基本思想为先将要排序的序列构成一个大顶堆，此时整个序列的最大值即为大顶堆的根节点，将其和堆的最后一个元素交换，其次堆的最后一个元素就变成了最大值。然后将剩余的n-1个序列重新构成一个大顶堆，这样就可以得到n个元素中的次大值，如此反复进行，即可得到一个有序序列。

堆排序的主要时间花在初始建堆期间和重建堆的反复筛选上，整个构建堆的复杂度为0(nlogn)。建好堆后，堆这种数据结构以及它奇妙的特征，使得找到数列中最大的数字这样的操作只需要O(1)的时间复杂度，维护需要logn的时间复杂度。由于初始建堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件，而适合于数据量非常大的场合（百万数据）。堆排序不需要大量的递归或者多维的暂存数组。这对于数据量非常巨大的序列是合适的。比如超过数百万条记录，因为快速排序，归并排序都使用递归来设计算法，在数据量非常大的时候，可能会发生堆栈溢出错误。

堆排序对原始记录的排序并不敏感，因此无论是最好最坏还是平均的时间复杂度都是0(nlogn)，且在空间复杂度上，它只有一个用来交换的暂存单元。

不过由于记录的比较和交换是跳跃式进行的，因此堆排序不是稳定的。

## 6.归并排序(Merge Sort)

归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用，基于完全二叉树的排序思想。将n个记录看成n个有序的子序列，然后两两归并，得到[n/2]\(不小于n/2的最小整数)个长度为2或为1的有序子序列，再两两归并，如此重复直至得到一个长度为n的有序序列。这种排序方法成为2路归并排序。

每轮排序需要对待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行logn次，因此，总的时间复杂度为O(nlogn)，且归并排序对原始序列的顺序不敏感，无论是最好最坏还是平均的时间复杂度都是0(nlogn)。

归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为logn的栈空间，因此空间复杂度为O(n)。

归并算法需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。

总的来说，归并排序是一种比较占用内存，但是效率高且稳定的算法。

## 7.快速排序(Quik Sort)

快速排序法由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一。

快速排序是一个就地排序，分而治之，大规模递归的算法。从本质上来说，它是归并排序的就地版本。

快速排序的基本思想为：通过一趟排序将待排序列记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，再分别对这两个序列继续进行分割排序，以达到整体有序的目的。

快速排序比大部分排序算法都要快。尽管我们可以在某些特殊的情况下写出比快速排序快的算法，但是就通常情况而言，没有比它更快的了。

快速排序是递归的，递归会造成栈空间的使用，最好情况递归树的深度为logn，其空间复杂度为O(logn)；最坏情况需要进行n-1次递归调用，其空间复杂度为O(n)，平均情况，其空间复杂度为O(n)。对于内存非常有限的机器来说，它不是一个好的选择。

由于关键字的比较是跳跃式进行的，因此快速排序是不稳定的。