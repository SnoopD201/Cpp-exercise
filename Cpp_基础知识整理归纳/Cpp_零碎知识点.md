## 1.常用编程小技巧

```c++
1.将数字将换成字符：
{
	char c; int a;
c = a + '0';
}

2.怎么使控制台exe.运行完程序后不退出：
在return(0)前面加上while(1)或者system('pause')或者getchar()

3.for(;(c=getchar())!='\n';)  cout<<c;
输入一个字符后立即输出该字符，直到遇到换行符为止
请注意：从终端键盘向计算机输入时,是在按Enter键以后才送到内存缓冲区。程序在执行过程中，会去内存缓冲区读取需要的数据。

4.for (int i = 0; i < 10; i++)  cin >> a[i]：这种可以直接输入十个数，也可以一个一个输入

5.const char  *p;					//使用字符指针时必须把指针定义为const
p = "I love china!";			    //字符串常量不用加取地址
cout << p << endl;

6.n>>1; //表示按位向右移动一位，若是整数，前面补0，若是负数，前面补1；但是这样n值不变
n=n>>1//这样n的值才会变,也可以写成n>>=1；
```

## 2.关于头文件的引用

在另一个源文件定义函数时需要把涉及到的声明全部include进来，需要用到输入输出时需要把(#include <iostream>,using namespace写上)。

在在另一个源文件中定义类的函数时需要把类的声明包含进来。且自己定义的类的声明后面必须加.h(#include <sort.h>)

## 3.NULL与nullptr

在C语言中，NULL通常被定义为：#define NULL ((void *)0)

所以说NULL实际上是一个空指针，如果在C语言中写入以下代码，编译是没有问题的，因为在C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针。

int  *pi = NULL;
char *pc = NULL;

但是问题来了，以上代码如果使用C++编译器来编译则是会出错的，因为C++是强类型语言，void*是不能隐式转换成其他类型的指针的

所以引入nullptr，专门用来区分0、NULL。

nullptr的类型为nullptr_t，能够隐式的转换为任何指针。

所以要返回一个自定义的指针类型的空指针需要用return nullptr。但在判断时都可以用pHead==NULL这种。

## 4.正码反码补码

计算机中的有符号数有三种表示方法，即[原码](https://baike.baidu.com/item/原码/1097586)、[反码](https://baike.baidu.com/item/反码/769985)和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同  。在[计算机](https://baike.baidu.com/item/计算机/140338)系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理，让符号位也参与运算，使得减法可以按照加法统一处理，简化了计算机的加减运算。(具体为什么可以这样需要用到膜和同余的概念)

原码：就是一个数的二进制表示，是我们最熟悉的二进制有符号数的表示方式。原码也有符号位，正数的话符号位为0，负数为1。
例：15的原码就是0000 1111；-15的原码就是1000 1111。

反码：反码是基于原码的变动，有两种情况，如果是正数的反码，就跟原码相同。如果是负数的反码，则除了符号位，其他全部取反
例：15的反码就是0000 1111；-15的反码就是1111 0000。对于反码，虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]~原~和[1000 0000]~原~（即反码10000000和反码111111111）两个编码表示0.

补码：补码是基于反码的变动，有两种情况，如果是正数的补码，就跟原码反码都相同。如果是负数的补码，则在其反码的基础上，再加1。对于8位，0的 补码是00000000，-1的补码是111111111，而最小的-128的补码是10000000。对于非最小的负数，已知补码求原码就是对补码再求补码，而对于最小的负数则是特殊的，其原码为0.使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].对于32个bit,即int型正数，范围为-2147483648-2147483647.

2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补=[00000001]补=1(补码进行运算时最前面的符号位当然也要参与运算)