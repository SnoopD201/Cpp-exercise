# C++基础知识整理归纳

## 1.C++初步知识

低级语言：机器或汇编语言

1954年出现高级语言FORTRAN，之后出现C(1972年有贝尔实验室的D.M.Ritchie发明)和BASIC(1964年在FORTRAN语言的基础上简化而来)，1980年贝尔实验室的Bjarne Stroustrup发明C++。

C语言：是结构化和模块化的语言，是基于过程的。容易处理较小规模的程序，但当问题比较复杂，程序规模较大时，结构话语言就显得不足。

C++：(1).在基于过程的机制基础上，对C语言做了不少扩充。 (2).增加了面向对象的机制

C++的特点：

>1. 类可以体现数据的封装性和信息屏蔽

C++的实现过程：

>1. 用C++语言编写程序，生成.cpp文件
>2. 编译:用编译器(complier)把原程序翻译成二进制的目标程序，生成.obj文件
>3. 连接：用系统提供的连接程序(linker)将所有的目标文件和系统的库函数以及系统提供的某些其他信息连接起来，生成可执行文件.exe
>4. 运行程序：运动最终形成的可执行的二进制文件(.exe)，得到运行结果



### 最简单的C++程序

```c++
#include <iostream>   //预处理指令,在程序进行编译时，将先对所有的预处理指令进行处理，将头文件的具体内容插入到include处
using namespace std;  //使用命名空间std,C++标准库中的类和函数是在命名空间std中声明的
int main()            //一个c++程序总是从main函数开始执行，若程序不能正常执行，向系统返回一个非零值(一般是-1)
{
    int a;
    cin>>a;
    cout<<a;
    return 0;
}
```

### 头文件

头文件是源文件之间的接口。利用#include指令，可以把不同的文件组合在一起，形成一个文件，避免重复编写代码，提高了编程效率。

头文件(.h)一般包含以下几类：

* 对类型的声明：对结构体或类的声明(而真正的定义放在源文件中)
* 函数声明：为方便用户，可以将同一类的函数声明集中在一个头文件中(如cmath集中了各类数学函数的原型声明)。而函数的定义不是放在头文件中，而是放在函数库或单独编译成目标文件，在编译阶段与用户文件连接组成可执行文件。
* 内置函数的定义：直接定义不要再声明了
* 宏定义：用define定义的符号常量和用const声明的常变量
* 全局变量声明
* 外部变量声明:如extern int a;
* 根据需要可以包含其他头文件

## 2.数据类型与表达式

### c++的数据类型

> 基本类型
>
> > 整形
> >
> > > 短整型(short int 或short)
> > >
> > > 整形(int)
> > >
> > > 长整型(long int 或long)：数字末尾加L或者l表示长整型，前面加0表示8进制，前面加0x表示16进制
> > >
> > > 整型数据之间的赋值：
> > > 按存储单元中的存储形式直接传送。如short int类型的-1以补码形式储存为1111111111111111，赋值给unsigned int则变成了65535.
> > > 将整型赋值给char型，只将其低8位原封不动的送给char型变量.
> > >
> > > 补码：
> > > 在计算机中，数值的存储一律用补码，因为补码可以将符号位与数值域统一处理，加法和减法也可以统一处理。
> > > 符号位:0表示正数，1表示负数
> > > 原码求补码:正数与原码相同，负数将原码除符号位取反再加1，0的补码表示是唯一的00000000.
> >
> > 字符型(char)
> >
> > > 普通字符常量：用单撇号括起来。字符常量使用ASCII码存储的，可以与整数进行混合运算。A对应的ASCII码为65，a对应97。
> > >
> > > 转义字符：'\n'等。 
> > >
> > > 字符串常量：用双撇号括起来，在计算机中存储时会在末尾加一个\0，多占一个字节
> > >
> > > ```c++
> > > 从左到右看,如"I say \"thanks\"\n"为I say "thanks"然后换行
> > > ```
> >
> > 浮点型：可以写成十进制小数形式或者指数形式，但在内存中都是以指数形式(即浮点形式)进行存储，符号在前面，小数部分在中间，指数部分在后面。在存储单元中小数部分和指数部分都是用二进制表示的，不能无限精确。
> >
> > > 单精度型(float)：6为有效数字，4个字节
> > >
> > > 双精度型(double)：15位有效数字，8个字节
> > >
> > > 长双精度型(long double)
> >
> > 布尔型(bool)
> >
> > > false=0,true=1.布尔型可以与数值型数据进行混合运算，true当成1,false当成0，cout<<true为输出1.
>
> 空类型(void)
>
> 派生类型
>
> > 指针类型(*)
> >
> > 数组类型([])
> >
> > 类类型(class)
> >
> > 共用体类型(union)
> >
> > 枚举类型(enum)
> >
> > 结构体类型(struct)
> >
>

### 符号常量

为方便编程和阅读，用一个标识符代表一个字符串常量，在预编译时把所有的符号常量换成所指定的字符串。如：

```c++
#define 宏名 字符串
#define uchar unsigned char  //自己定义的符号放中间
```

特点是含义清楚，可以做到“见名知意”，一个在修改一个常量时可以“一改全改”

#### 符号常量与const常变量的区别：

在定义常变量时必须同时对它初始化(即指定其值)，此后不能再对其赋值。const int a=3;

符号常量只是用一个符号代表一个字符串，在编译时把所有符号常量替换为指定的字符串，它没有类型，没有名字，在内存中并不存在以符号常量命名的存储单元。而常变量是一个变量，有名字，在存储中有以它命名的存储单元，可以用sizeof测出其长度，只是其值不能修改。且常变量可以是字符或数值型，符号常量只代表一个字符串。

### 变量

变量有三个属性，存储类别，作用域，存储期

#### 作用域

##### 局部变量

local variable.在一个函数或复合语句内部定义的变量是内部变量，它只在本函数或本复合语句在有效，在外部无效。在main函数在定义的变量也不可以在其他函数中使用。

##### 全局变量

global variable.在函数之外定义的变量为全局变量，其有效范围从定义变量的位置开始到源文件结束。如在main函数上面定义的全局变量可以在所有函数中使用,且在其他函数中不需要再定义一次。如在同一个源文件中，全局变量和局部变量重名，则全局变量被屏蔽。

建议不在必要时不使用全局变量，因为全局变量在程序全部执行过程中都占用存储单元，且它使函数的通用性降低了。
在程序设计时，在划分模块时要求模块的内聚性强，耦合性弱。即模块的功能要单一，与其他模块的相互影响要尽量少。这样程序移植性好，可读性强。

#### 存储类别

内存分为程序区，静态存储区和动态存储区。存储方法有动态存储和静态存储，全局变量放在静态存储区，函数的形式参数、局部变量和函数调用时的现场保护和返回地址等放在动态存储区。

##### 自动变量(auto)

函数中的局部变量，如果不加static声明,就是自动变量，可以加aotu修饰，也可以不加，属于动态存储方式。

##### 用static声明静态局部变量

在函数调用结束后不消失而保留原值。属于静态存储方式。
对静态局部变量是在编译时赋初值的，即只赋值一次。

##### 用register声明寄存器变量

对于使用频繁的变量，不存放在内存中，而直接存储在寄存器中。在函数调用结束后并不保留原值。

##### 用extern声明外部变量

###### 在一个文件内声明全局变量

在一个函数内用extern对变量做外部变量声明，可以提前引用。

###### 在多个文件中声明外部变量

在一个文件内定义int a=3, 在另一个文件中做外部变量声明 extern int a,从而扩展其作用域。不能在多个文件中重复定义外部变量。

##### 用static声明静态外部变量

对外部变量加上static声明,则该外部变量无法被其他文件引用。

### c++运算符与表达式

<img src="D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\运算符和结合性1.png" alt="运算符和结合性1" style="zoom:67%;" />

![运算符和结合性2](D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\运算符和结合性2.png)

![运算符和结合性3](D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\运算符和结合性3.png)

#### 逗号运算符与逗号表达式

x=表达式1，表达式2  //先求解表达式1，再求解表达式2，整个表达式的值就是表达式2的值

```c++
a=5;
a=2*3,4*a;  //a=2*3是表达式1，先得到a=6，然后计算表达式为24,所以整个表达式的值为24.但是a仍为6,因为表达式2没有重新对a进行赋值
```

#### 条件运算符与条件表达式

C++中唯一的三元运算符，条件运算符强大而独特，它提供了一种表达简单if-else语句的简写方法

```c++
逻辑表达式?表达式1:表达式;  //第一个表达式为真，则运行表达式1,表达式1的值为整个条件表达式的值;为假则运行表达式2，2为整个表达式的值
```

#### 其他表达式

记住：任何表达式都有一个确定的值

优先级：  ！>算术表达式>关系表达式>&&和||>赋值表达式

## 3.语法提要

### 输入输出

#### cin和cout

在c++中配合输入输出控制符对基本类型进行输入输出（#include <iomanip>）

```c++
cout<<setiosflags(ios::fixed)<<setprecion(10)<<a; 	   //设置浮点数以固定的小数位显示,10为小数位数
cout<<setiosflags(ios::scientific)<<setprecion<<(6)<<a;//设置浮点数以科学计数法显示,6为小数位数
//以上3个控制符设置一次对以后的输出均有效(除非重新设置)
cout<<setfill('*')<<setw(10)<<a;                       //固定字段宽度为10位，不足前面用*填充
```

#### getchar()和putchar()

C中对字符进行输入输出

```c++
char c;
c=getchar();  //从终端读取一个字符
putchar(c);   //输出一个字符
cout<<getchar;//输出字符的ASCII码
cout<<(c=getchar());//输出字符
```

#### scanf和printf

C中对所有基本类型进行输入输出

```c++
scanf(格式控制,输入表列),如scanf("%d %c %f",&a,&b,&c)
printf(格式控制,输出表列),如printf("a=%d,b=%c,c=%f\n",a,b,c)
```

### if语句

```c++
if(x==0) y=1;  
if(x>0) y=1;
else if(x=0) y=0;  //可以有0个或多个else if
	if(x!=0) y=-1; //可以随便嵌套，程序会自动分辨对应的级别
else			   //若是多个语句则放在大括号里
{
    y=-1;
    cout<<y;
}
```

### switch语句

```c++
switch(表达式)  //这里的表达式是数值类型(包括字符类型)数据
{
    case 常量表达式1:语句1;  //可以是多个语句写在一行
    case 常量表达式2:语句2;  //进入到一个case语句中会一直往下执行，所以一般需要用break跳出当前大括号
    default :语句n;
}
```

### while循环语句

```c++
while(表达式) 执行语句;  //先判断后执行。若是复合语句，用大括号括起来放在下面
do
    语句               //先执行后判断。若是复合语句，用大括号括起来放在下面
while(表达式)；         //注意while后面有;
```

### for循环语句

```c++
for(循环变量设初值;循环条件;循环变量增值)  语句;  //若是复合语句，用大括号括起来放在下面
for(循环变量设初值;循环条件;循环变量增值);       //还可以后面不跟执行语句，将执行语言放在第二或第三个表达式里
//for括号内的三个表达式都可以适当省略
```

## 4.函数

一个函数function就是一个功能，C++中除主函数的大多数函数都封装在类中。

int max(int x,int y)    //如果函数值的类型和return语句返回的值类型不一致，以函数类型为准，自动进行类型转换

函数的实参变量对形参变量的数据传递是"值传递",即单向传递，调用结束后，形参单元被释放，实参单元仍维持原值不变

函数原型(function prototype)：int max(int,int),在函数声明时可以不写形参名(写了也可以与定义函数时不相同)，只写形参类型，在编译时会根据函数原型对调用函数的合法性进行检查。

### 函数的嵌套调用

所有的函数都是平行的(包括main函数),在定义函数时是独立的，函数不能**嵌套定义**，既不能在定义一个函数的过程中又定义另一个函数，也不能把函数的定义部分写在主函数中。

但C++可以嵌套调用函数，即在调用一个函数的过程中又调用另一个函数。可以把函数2在函数1中声明，但把函数2的定义写在函数1的外面。

### 函数的递归调用

在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用(recursive)

```c++
//用递归方法求n!
long fac(int n)   //无需再函数前面添加recursive
{
    long f;  //关键是用一个变量代表函数返回值
    if(n<0) {cout<<"n<0,data error!";return -1;}
    else if(n=1||n=0) f=1;  //设置递归结束条件
    else f=n*f(n-1);
    return f;
}
```

### 内置函数

inline int max(int ,int)  //当函数规模很小时，函数调用的时间甚至超过执行函数本身的时间，为提高效率，在编译时直接将函数的代码嵌入到主调函数中，而不是将流程转出去。适用于规模很小而频繁使用的函数(如定时采集数据的函数),在函数中不能包含复杂的控制语句(如循环语句和switch语句)

### 函数的重载

function overloading.对一个函数名重新赋予新的含义，实现"一物多用"，一般一些功能相近的函数可以用函数重载。

C++允许用同一个函数名定义多个函数，这些函数的参数个数和参数类型和函数的返回类型和函数体可以不同，但要求**函数的参数个数、参数类型或参数顺序**三者中必须至少有一个不同，否则无法知道调用的是哪个函数。

### 函数模板

function template:建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚的类型来代表。凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。适用于函数体和参数个数相同而类型不同的情况，对函数的重载进行了进一步的化简。

```c++
template<typename T>  //模板声明，其中T类型参数，可以根据需要声明多个,typename也可以写成class,可以互换，都表示类型名
T max(T a,T b)
{
    return(a>b?a:b);
}
```

### 有默认参数的函数

int max(int a,int b,int c=0,float d=0)
实参与形参的结合是从左到右的，因此指定了默认值的参数必须都放在形参列表的最右端
如果函数的定义在函数调用之前，则应在函数定义中给出默认值。如果函数的定义在函数调用之后，则在函数声明中给出默认值，函数定义中可以不给出。也就是说，必须在函数调用前将默认值的信息通知编译系统。

### 内部函数和外部函数

静态函数: 在函数定义前面加static，则该函数只能被本文件中的函数调用，不能被其他文件调用

外部函数: 在函数声明前加extern ，表明该函数定义在另一个文件。用函数原型定义的话，extern可以省略不写

## 5.数组

数组是属于线性表的线性存储结构。所谓数组，就是用一个统一的名字代表这批数据，而用序号或下标来区分各个数据。

### 定义和引用数组

类型名 数组名[常量表达式]         如：int a[10]; int a[2*n]  前面已经定义了n为常变量。
常量表达式可以包括常量，常变量和符号常量，但不能包含变量，即不能对数组大小做动态定义。

#### 数组的初始化

在定义时对全部元素赋值，如int a[5]={1,2,3,4,5};

在定义时对部分元素赋值,如int a[5]={1,2};int a[2] [3]={{1,2},{3,4},{5,6}}或 int a[2] [3]={1,2,3,4,5,6};  int a[][][3] [4]={{1},{1,2},{}};
未赋值的元素系统会根据元素类型自动指定其值(数值型为0,字符型为空字符'\0')

在对全部元素赋初值时，可以不指定数组长度，系统会自动判定(默认给出的全部元素的个数就是数组的长度)。
如int a[]={1，2，3，4，5}.
但对于二维数组或多维数组,只能省略第一维的长度。如int a[] [4]={1,1,1,1,2,2,2,2};

#### 数组名

一维数组名a是一个指针，其值是数组第一个元素的地址。如int *p=&a[0]与int *p=a等价。数组名是指针常量，不能改变，如：不能a++,但可以用表达式a+1。

对于二维数组，a[0],a[1]就是一个指针，指向每行的起始元素。

数组元素和普通变量一样，可以随便赋值引用等。但**数组名代表一个固定的地址，不能赋值**，即数组除在初始化时不能整体赋值，如不能a={1,2,3,4,5}或两个数组相互赋值a=b;

数组名做函数参数，如void selcet(int arry[])或void select(int *p)       实参可以是数组名或者指针变量，形参可以写元素个数也可以不写，C++只是把形参数组名作为一个**指针变量**来处理，从而接受从实参传过来的地址。
做实参，如select(a)：用数组名做实参时，传递的是首元素的地址(址传递)，如果改变了形参数组元素的值，实参数组也会同样改变。

### 字符数组和字符串类型

#### 字符数组

即元素是字符的数组，这是C语言采取的方法，一般称为C-string

**字符数组初始化：**char c[5]={'a','b','c','d','e'}	还可以用字符串常量来进行初始化,如char c[]={"I love China"}或="I love China";
注意:“I like”返回的是一个字符串的首字符的地址，系统会自动给字符串常量后面加一个'\0'作为结束标志，在内存中多占一个字节。赋值时'\0'也会赋给字符数组，如char c[]={"I love China"}或="I love China"会使数组的长度自动设为13(比字符数目多一个)。

字符数组可以一次性输入输出，如cin>>a;cout<<a; 但数值型数组不能一次性输入输出。

##### 字符串处理函数

需要#include <string>

字符串连接函数**strcat:**
函数原型为strcat(char [],const char[], （用const保证数组2的内容不会在函数调用期间被修改）将2加到1后面，函数返回值是第一个字符数组的地址

字符串复制函数**strcpy:**

函数原型为strcpy(char [],const char [])，将第2个字符数组的字符串赋值到第一个字符数组中去，将第一个字符数组中的相应字符覆盖。
strcpy(a,"I love China",2)，将前面两个字符赋值到a

字符串比较函数**strcmp：**
函数原型为strcmp(const char [],const char[])，返回值是一个整数：1=2，返回0；1>2，返回正整数；1<2，返回负整数。字符数组名或字符串常量不能直接比较大小,如str1>str2,"I Love"<"I like"

字符串长度函数**strlen:**
函数原型为strlen(const char [])，返回值是字符串的实际长度，不包括'\0'

**以上处理函数的实参和形参都是指针变量**

#### 字符串类型

C++提供了一个新的数据类型，字符串类型，string，用法与其他基本数据类型一样。

需要#include <string>

string string1="China";

字符串可以直接赋值，可以用+连接两个字符串，字符串的比较可以直接用关系运算符。

##### 字符串数组

string name[3]={"zhang","li","yang"}

## 6.指针

### 定义和引用指针

在程序中一般是通过变量名来对内存单元进行存取操作，变量名在编译时转变为变量的地址，这种按变量地址存取变量值的方式为**直接存取**方式。

将一个变量的地址存放在另一个变量中，叫做**间接存取**。这种专门用来存放地址的变量叫做指针变量。指针变量的值/变量的地址叫做指针。

&:取地址运算符		*:指针运算符

定义指针变量 int *p;	不能用一个整数给指针变量赋值，如int *p=2000;  只能将一个指针赋给指针变量，如p=&a;  

若定义int *p=&a，则p=&a,  \*p=a, &\*p=&a,	*&a=a;

指针变量可以运算，如p+1或p++表示当前地址加上一个所指向数据类型占据的地址。

### 指向数组元素的指针

数组名代表首元素的地址(与一般的变量名不同)，int *p=a与int *p=&a[0]等价，指向数组元素的指针与指向一般变量的指针一样，没有指向数组的指针，只有指向数组某一元素的指针。

若定义int *p=a，则p+i,a+i,&a[i]等价，都是指向数组第i个元素的地址。
			*(p+i), \*(a+i), a[i], p[i]等价，都是数组第i个元素的值。

(若指针指向一般的变量，如int int *p=&a,则p与&a等价，\*p与a等价；若指针指向数组元素int *p=a，则p与a等价)

### 用字符指针指向字符串

char *p="I love China"，或char *p,p="I love China"。使p的值为字符串第一个字符的地址。

```c++
//利用字符指针将字符串1复制给字符串2
char str1[]="I love China",str2[20],*p1,*p2;
p1=str1;p2=str2;
for(;*p1!='\0';p1++,p2++)
    *p2=*p1;
*p2='\0';
p1=str1;p2=str2;
cout<<"str1 is:"<<p1<<endl;
cout<<"str2 is:"<<p2<<endl;
```

### 函数与指针

#### 函数指针

指针变量可以指向一个函数。一个函数在编译时被分配给一个入口地址，这个函数入口地址就是函数的指针。可以用一个函数指针指向函数，然后通过调用此指针调用此函数。

定义：int (*p)(int,int)

赋值：int max(int x,int y)，则可以p=max

调用：p(x,y)    	//相当于用函数指针名代替函数名

函数指针还可以做函数参数，在调用时将函数名当实参进行传递。

#### 返回指针值的函数

定义：int *a(int x,int y)

表示此函数的返回值为指针。

### 指针数组

定义：int *a[10]			(int (\*a)[10]为指向包含10个元素的一维数组的指针变量)

如果一个数组，其元素都是指针变量，则成为指针数组。

#### 指向指针的指针

定义：int **p

a+i其实就是指向指针的指针，*(p+i)=a[i]是指针数组第i个元素。

```c++
利用指针数组对字符串进行排序
void sort(char *a[],int n);
void print(char *a[],int n);
char *name[]={"FORTRAN","C","C++","JAVA","PYTHON"};
int n=5;
sort(name,n);
print(name,n);

void sort(char *a[],int n)
{
    char *temp;
    int k;
    for(int i=0;i<n-1;i++)
    {
        k=i;
        for(int j=i;j<n;j++)
        {
            if(strcmp(a[j],a[k])<0) k=j;    
        }
        if(k!=i)
        {
            temp=a[i];             //a[i]=name[i],是指针数组的第i个元素，也是一个指针。
            a[i]=a[k];
            a[k]=a[i];
        }
    }
}

void print(char *a[],int n)
{
    for(int i=0;i<n;i++)
    {
        cout<<a[i]<<endl;    //若定义 char **p=a,则a[i]可以用*(p+i)或p[i]代替。
    }
}
```

### const指针

#### 指向常量的指针变量

定义：const int \**p=&a;
不允许通过指针变量改变它所指向的值，即不能*\*p=2;	但可以改变指针变量的值，如可以p=&b;	变量仍可以改变，如a=2;

#### 常指针

定义：int * const p=&a;
不允许改变常指针的指向，即指针值不能改变，即不能p=&b；但可以改变常指针指向的变量的值，如*p=2;

#### 指向常量的常指针

定义：const int * const p=&a
既不能改变指针变量的指向，也不能通过指针变量改变变量的值。
以上三种方式都不能限制直接通过变量名改变变量的值，要是变量的值绝对不能变，需要定义常变量，const int a=2.

### void指针类型

定义：void *p;

void指针变量，其仍可以有确定的值，但不指向任何类型的数据，可理解为指向空类型或指向不确定的类型。一般作为过渡指针。

可以把非void型的指针赋给void型指针变量，但不能把void指针直接赋给非void 型指针变量，必须先进行强制转换。

```c++
int a=3;
int *p1=&a;
void *p2;
p2=p1或p2=(void *)p1;        //p1的值赋给p2
不能cout<<*p2,应为p2为void指针，需要先转换，可以cout<<*(int *)p2,即输出3
不能p1=p2,可以p1=(int *)p2
```

##### NULL

指针变量可以有空值，即该指针不指向任何变量，但该指针仍是有值的，p=NULL就是p=0，就是使p指向地址为0的单元，即指针不指向任何有效的单元。

### 传值方式与传址方式

#### 引用(reference)

对一个数据建立一个引用，作用是为变量起一个别名。

如：int a; int &b=a;	声明了b是a的引用，即b是a的别名，通过b可以引用a，也就是b和a是同一个东西了。改变了引用的值也会改变变量的值，也可以对引用取地址，如&b即是&a。声明完引用后不能再重新声明其为另一个变量的引用。

引用不是一种独立的数据类型，对引用只有声明，没有定义，在声明一个引用时必须使之初始化，即声明它代表哪个变量。

C++之所以增加引用机制，主要是把它作为函数参数，以扩充函数传递数据的功能，

```c++
#include <iostream>
using namespace;
int main()
{
    void swap(int ,int);
    void swap(int *,int *);
    void swap(int &,int &);
    int i=2,j=3;
    swap(i,j);
    swap(&i,&j);
    swap(i,j);
    return 0;
}

void swap(int i,int j)   //变量作为形参
{
    int temp;
    temp=j;
    j=i;
    i=temp;
}

void swap(int *i,int *j)  //指针作为形参
{
    int temp;
    temp=*j;
    *j=*i;
    *i=temp;
}

void swap(int &i,int &j)  //引用作为形参
{
    int temp;
    temp=j;
    j=i;
    i=temp;
}

/*
前两种方式传递的都是实参的值，属于传值方式，会开辟新的内存单元，进行虚实结合。第一种传递的是变量的值，第二种传递的是指针变量的值(即地址)，这两种方式在调用函数过程中都不能改变实参的值。且在调用函数过程中需要为形参分配存储单元，用来接收实参的值，实参和形参的存储单元不同，第一种方式开辟的空间与实参所需空间相同(可能需要很多个字节)，第二种方式需要开辟一个空间存放指针(一般为4个字节)。虽然第二中方式可以通过形参指针变量改变实参的值，但是却兜了一个圈子，不那么直接了当。

第三种方式传递的是实参的地址，属于传址方式。可以把实参的地址传递给形参，使形参作为实参的引用，使形参和实参的地址相同。改变形参即可直接改变实参，且不需要为形参额外开辟空间，不生成临时变量(实参的副本)。这种方式更加方便直接，减少了时间和空间的开销。
*/
```

### 利用指针的优点

* 用法比较灵活，可以提高编程效率
* 用指针变量作为函数参数，在调用函数过程中可以改变实参所指向的变量的值
* 可以实现动态存储分配

## 7.自定义数据类型

### 结构体类型

在一个组合项中包含若干类型不同(当然也可以相同)的数据类型，叫做结构体。

```c++
声明：struct Student    //结构体类型名，相当于int ,float等基本类型。结构体类型名可以省略直接定义结构体变量，但是不建议这样做
{                      //声明结构体类型时不分配空间，而定义结构体变量时需要分配空间
    int num;           //每个成员也称一个域(filed)，成员表又成为域表
    char name[20];     //包含字符数组的话需要指定数组长度
    Date birtgday      //Date是另一个结构体类型名，一个结构体中可以包含两一个结构体
    Student *p;        //指向自身类型的指针
}  stu1[3]={{101,"cuiyugui1",2020,03,15,NULL},{102,"cuiyugui2",2020,03,15,NULL},{103,"cuiyugui3",2020,03,15,NULL}}；
//可以在声明时定义和初始化结构体变量，也可以先声明后定义。结构体变量和普通变量一样，可以随意操作，包括取地址。
//结构体变量可以整体赋值或相同类型结构体变量相互赋值，但不能整体输入输出。
引用结构变量：结构体变量名.成员名        如stu1[1].num=108;
```

#### 指向结构体变量的指针

Student \*p=&student      //指针类型要用结构体类型，而不能用结构体变量。结构体变量名与数组名不同，不代表地址，需要加&。
//定义后，\*p等价与student，即student.num=(*p).num=p->num

```c++
结构体变量可以做函数参数，指向结构体变量的指针可以做函数参数，结构体变量的引用也可以做函数参数
    void print(Stu stu1);    
    void print(Stu  *);
    void print(Stu &);
```

#### 用new和delete运算符进行动态分配和撤销存储空间

C++提供new和delect来代替malloc和free，new和delete是运算符，不是函数，执行效率高。

 ```c++
new int;     //开辟一个存放整数类型的空间，并返回一个指向该存储空间的地址
new int(10)  //开辟一个存放整数类型的空间，指定其初值为10，并返回一个指向该存储空间的地址
int *p=new int(10) //开辟一个存放整数类型的空间，指定其初值为10，并返回一个指向该存储空间的地址给指针变量p
new char[5]  //开辟一个存放字符数组(包含5个元素)的的空间，并返回一个指向该存储空间的地址。用new分配数组空间不能指定初值
Stu *p=new Stu //动态开辟结构体类型空间，可以建立动态链表
//如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据返回指针的值判断分配空间是否成功
    
delete用法：delete 指针变量      //撤销指针变量所指向的变量的空间
           delete [] 指针变量   //撤销指针变量所指向的数组的空间
 ```

### 共用体类型

```c+
union Data 
{
int i;           
char n;
double f;
};
//共用体与结构体不同之处在于：系统为结构体中各成员分别分配存储单元，而共用体则是个成员共用一段存储单元。这样可以节省空间。
```

### 枚举类型

枚举(enumeration)类型的枚举变量只能用几种不同的取值。利用枚举变量可以把变量的值限制在一定范围内。

```c++
enum weekday{sun,mon,tue,wed,thu,fri,sat};   //声明枚举类型
weekday week1;    //定义枚举变量
//枚举元素按常量处理，故称枚举常量，不能对枚举元素赋值。
//枚举元素的值按顺序自动赋值为0，1，2...相当于设置了符号常量，可以进行数值运算，如for(int i=sun;i<=sat;i++)。
//可以输出枚举变量，但输出的是整数，如cout<<week1输出的是0
//不能把一个整数直接赋给一个枚举变量，枚举变量只能接受枚举类型数据，如week1=tue;要把整数赋给枚举变量，必须进行强制类型转换，如week1=weekday(2),相当于week1=tue;
```

### 用typedef声明新的类型名

声明一个新的类型名的方法：

1. 先按定义变量的方法写出定义语句，如int a[10]
2. 将变量名换成新的类型名，int NUM[10]
3. 在最前面加上typedef ，typedef int NUM[10]
4. 然后可以用新的类型名去定义变量，NUM a，a就是一个有是个元素的数组名，a[1]就是数组的第一个元素

```c++
typedef int INTEGER  
typedef struct    //这里不要写结构体类型名
{
    int month;
    int day;
    int year;
} DATA;   //声明DATA代表上面指定的结构体类型
typedef char * STRING  //声明STRING为字符指针类型
typedef int (*Pointer_to_Function)()   //声明Pointer_to_Function为指向函数的指针类型 
//用trpedef相当与给类型名取一个别名，并没有创造新的类型
//用typedef可以声明数组类型，字符串类型，使用比较方便
    如typedef int ARR[10]，ARR a,b,c。
```

#### 优点

* 开发程序时常用typedef声明不同的数据类型，把他们单独放在一个头文件中，可以用#include把它们包括到本文件中，就可以使用这些typedef类型名。这样方便编程，提供编程效率
* 使用typedef类型名去定义变量，可以在修改typedef声明时一次性修改全部变量的类型，有利于程序的通用和移植。

---



# C++面向对象编程(OOP-Object Oriented Programing)

## 1.类和对象基础

对于基于过程的结构化编程：程序=算法+数据结构
算法和数据结构是相互独立、分开设计的，基于过程的程序设计是以算法为主体。

而面向对象的编程设计关注的则是对象，认为数据结构和算法是一个紧密相连不可分割的整体，将算法和数据封装成一个对象：
                                            **对象=算法+数据结构（即一组数据和操作数据的一组函数）**
                                            **程序=对象+对象+对象+...消息(消息就是对对象的控制，在程序就是调用对象成员函数的一个命令语句)**

在基于过程的程序中，函数是构成程序的基本部分，程序面对的是一个个的函数。每个函数都是独立的，除了主函数只能被操作系统调用外，各函数之间可以相互调用，所有的数据都是公用的。设计者必须考虑程序中的每一个细节，确定时候什么调用什么函数操作什么数据，当程序规模较大、操作种类繁多时，就比较难以应付，所以基于过程的程序设计只适合编写简单小型的程序；
而在面向对象的程序设计中，程序的基本构成单位是类，除主函数外，其他的函数基本都被封装在类中，程序面对的是一个个类和对象，程序设计的主要工作是根据实际问题及需求设计、定义类和对象，以及考虑怎样向对象发送消息以使对象完成所需任务。通过类和对象，可以将复杂的问题拆分为一个个小部件小零件，并可以通过调用对象将各个零件组成一个有机的整体，简化了程序设计的过程，提高了工作效率。

面向对象的程序设计有四个主要特点：**抽象，封装，继承，多态**

**抽象**：客观世界中的任何事物都可以看成一个对象，具有静态特征即属性，动态特征即行为，对象由一组属性和行为构成。通过类可以表示同一类事物的共同特征即本质，可以很好的模拟客观世界。类是对对象的抽象，对象是类的具体实现。类是抽象的，不占用内存，而对象是具体的，占用储存空间。

**封装**：对象将有关数据和操作封装为一个整体，各个对象之间相互独立、互不干扰。并且对象中的某些部分对外屏蔽，外部无法得知对象内部的世界，而通过留下少量的接口接受外界的消息与外界进行联系。公用的函数就是对象的对外接口。这样可以实现信息屏蔽(information hiding)，有利于数据安全，防止无关人员了解和改动数据。

**继承**：子类(派生类)可以继承父类(基类)的数据和函数，实现了软件重用(software reusability)。开发软件时不必重新定义类，可以根据需要使用已有的类，减少了编程工作量。

**多态**(polymorphism)：由继承而产生的不同派生类，其对象对同一个消息会做出不同的响应，增加了程序的灵活性。

```c++
类的声明：
    class 类名       //类名首字母一般大写，对象名首字母一般小写
    {
        public:    //public和private成为成员访问限定符。
        公有的数据和成员函数；  //一般将需要被外界调用的成员函数指定为public，使之成为类对外的接口
        private:   //私有的成员不能在类外调用，不能在类外使用对象名.成员，只能被本类中的成员函数调用，但友员除外。     
        私有的数据和成员函数；//无论成员是私有的还是公有的，都可以在类外通过类的接口即公有函数调用和修改。
    }；//别忘了逗号
对象成员的引用：
        通过对象名和成员运算符 ：对象名.成员，如Student stu1;st1.name;
        通过指向对象的指针 ：                Student *p=&stu1;*p.name,p->name;
        通过对象的引用 ：                   Student &s=stu1;s.name;
        
//与结构体的区别：为了和C兼容，在C++中struct结构体类型也可以包含成员函数，可以用struct来声明一个类，用法和class一致。但是用struct声明的类，如果没有对其成员做public和private声明，则默认是public的，而class则默认是private的。
//内置(inline)成员函数：如果在类中定义的成员函数不包含循环等控制语句结构简单时，C++系统会自动将它们作为内置函数，把函数代码嵌入程序的调用点，不用执行一般函数的调用过程，可以减少函数调用过程中的时间开销；如果在类外定义成员函数，系统则不默认为内置函数，需要用inline做显式声明。但在类外定义inline函数，必须将类定义和成员函数的定义放在同一个源文件中，否则编译系统无法将函数代码拷贝嵌入到函数的调用点。但这样做不利于信息屏蔽，所以只有在成员函数规模较小且使用频繁时才会将其定义为内置函数。
//成员函数的存储方式：无论成员函数是公用的还是私有的，无论其是不是内置函数，其都不占用对象的存储空间，一个对象的存储空间只和其数据成员相关，与成员函数无关。成员函数是属于类的，不同对象的函数的代码都是相同的，无论调用的是哪一个对象的函数，调用的都是相同的函数代码。C++通过this指针来指向不同的对象，通过不同的对象调用成员函数时，this会指向不同的对象。
```

### 类的封装性和信息屏蔽

#### 公用接口和私有实现的分离

公用成员函数是类的对外接口，是用户使用类的公用接口(public interface)。
通过成员函数对数据成员的操作是类的功能的实现，实现的具体细节被封装在类中，用户看不到成员函数的源代码，而只能接触成员函数的目标代码，类的功能的实现细节对用户是屏蔽的，这种实现成为私有实现。通过**公用接口和私有实现的分离**，即可以实现类的功能，又实现了信息屏蔽。
当接口与实现分离时，只要类的接口(即调用的成员函数的形参的类型和个数不变)没有改变，对私有实现的修改不会引起其他额外的修改，有利于修改和扩充类的功能。且如果编译过程中发现类中的数据读写出错，不必检查整个程序，只须检查本类中访问这些数据的少量成员函数，这使得程序的设计、修改和升级更加方便。

#### 类声明和成员函数定义的分离

在面向对象的程序开发中，往往将类的声明(其中包含成员函数的声明)放在头文件中，使用该类时只需要把头文件包含进来即可，类声明头文件就是用户实现类库的公用接口，不必在程序在重复书写类的声明，减少了编程工作量，提高了编程效率。

类的成员函数的定义不放在类的声明中，而放在另一个源文件中。

一个C++程序包含3个部分：(1)类声明头文件(.h后缀)	(2)类实现文件(.cpp后缀)，包含类成员函数的定义	(3)类的使用文件(.cpp后缀)，即主函数文件。   
在程序中用#include指令包含类声明头文件，在编译时会把类的使用文件和类实现文件按多文件程序的规定组成一个统一的程序，经过编译连接后运行。 如果对成员函数的定义也放在头文件中，那么类的使用文件每进行一次编译都会对成员函数进行一次编译，会导致成员函数的多次编译，这是没有必要的。 所以一般将类的成员函数定义放在单独的文件中，只需要编译一次，将目标文件(.obj)保存起来，在需要时将其与程序的目标文件连接起来。

在实际工作中，往往将若干个功能类似的类声明集中在一起，形成各种类库。类库包含两个部分：(1)多个类声明的头文件 (2)各个类的经过编译的成员函数，即目标文件。用户只需要把类库放到自己的计算机系统(C++编译系统所在的子目录下)，在程序中用#include指令将所需的头文件包含进来，即可使用这些类。

开发商只需要给用户提供其需要的类库，即类的声明和目标文件，不提供源文件，用户看不到函数定义的源代码，更无法修改源代码，软件开发者的权益得到保护。

### 构造函数和析构函数

C++提供了构造函数(constructor)来进行对象的初始化，构造函数是一种特殊的成员函数，不需要用户来调用它，而是在建立对象时自动执行。构造函数的名字必须与类名一样，它不具有任何类型，不返回任何值。在建立对象(即定义对象)时会为对象开辟内存，会自动调用构造函数，把指定的初值送给相应的数据成员的存储单元中。构造函数提供了初始化多个对象的统一方法，而不必对多个对象逐个显式的初始化。

析构函数(destructor)与构造函数作用相反，当对象的生命周期结束时，程序会自动调用析构函数。析构函数没有函数类型，不返回任何值，也没有函数参数。析构函数的作用不是删除对象，而是在撤销对象占用的内存单元之前完成一系列清理工作，如删除类中定义的指针。一个类可以有多个构造函数，但只能有一个析构函数。

一般情况下，对象的建立相对于一个栈，先进后出，调用析构函数的次序与调用构造函数的次序相反，先构造的后析构，后构造的先析构。

```c++
class Time        
{
    public:      //构造函数和析构函数都在public下面定义
    Time()       //在类内定义无参的构造函数。
    {
        hour=0;
        minute=0;
    }
    Time(int a,int b)；                      //在类内声明带参数的构造函数，还需要在类声明下面进行定义
    Time(int a,int b):hour(a),minute(b){}   //可以用参数化列表在类内直接定义带参数的构造函数
    Time(int a=10,int b=1)；      
    //在类内声明带默认参数的构造函数。还需要在类下面定义构造函数，但可以不再写默认参数。但需要注意，全部参数都指定了默认值的构造函数也属于默认构造函数，而类只能有一个默认构造函数，因此类不要同时定义无参的构造函数和全部参数都指定了默认值的构造函数。
        
    ~Time()              //析构函数一般直接在类内定义
    {
        cout<<"Destructor called"<<endl;
    }
    private:
    int hour;//不可以在类内初始化数据成员，如int hour=0;因为类并不是一个实体，不占用内存，无法容纳数据，定义变量时才会开辟空间。
    int minute;
};
//在类外定义成员函数，必须先在类内进行声明，且函数的定义必须放在类声明的后面。
//可以为一个类定义多个不同的构造函数(函数名字相同，而参数的个数或参数的类型不同)，这叫做构造函数的重载。
    Time::Time()  //在类外定义构造函数
    {             //这是一个无参构造函数，属于默认构造函数，即在程序中用Time tim1建立对象时会调用无参构造函数，如果未定义无参构                     造函数，系统会提供一个默认的构造函数。注意不要写成Time tim1();
        hour=0;
        minute=0;
    }
    Time::Time(int a,int b)  //带参数的构造函数
    {
        hour=a;
        minute=b;
    }

int main()
{
    Time tim1;           //建立对象时调用默认构造函数，不要用Time tim1();
    Time tim1(20,10);    //建立对象的同时指定数据成员的初值
    Time times[50]={
        Time(1,1),Time(2,2),Time(10,10)
    }
  //这是一个对象数组，可以在建立对象数组时，分别调用构造函数，对每个成员进行初始化。times[2].hour,可以像普通数组元素一样使用对象
}

//对象的赋值：
Time tim1,tim2(10,20);
tim1=tim2;
将一个已有的对象赋值给另一个已有的对象，这是通过成员复制(memberwise copy)来完成的,即将一个对象的成员值一一复制到另一个对象的对应成员的存储空间，对象的赋值只对其中的数据成员赋值，而不对成员函数赋值。注意数据成员中不能包括动态分配的数据，否则赋值时可能出现严重后果。
//复制构造函数：
    类名 对象名(已有对象名) //用一个已有的对象赋值新生成一个完全一样的对象。
    如Time tim2(tim1)或Time tim2=tim1；
    在建立对象时，调用一个特殊的构造函数——复制构造函数(copy constructor),原型为Time::Time(const Time&tim1)，复制构造函数也是构造函数，它只有一个参数，就是本类的对象，并且采用对象的引用方式。用户没有定义的话，编译系统会自动生成一个默认的复制构造函数，其作用只是简单地复制对象的每个数据成员。
    注意：对象的赋值是对一个已经存在的对象赋值，因此必须先定义被赋值的对象。而对象的复制则是从无到有建立一个新对象，使之与已有对象完全相同。
```

### 类模板

类模板是对类的抽象，类是类模板的实例。利用类模板可以建立含各种数据类型的类，使类的使用不受限于数据类型。

```c++
template<class numtype1,class numtype2>  //可以定义一个或多个类型参数名
    class Time
    {
        public:
        Time(numtype1 a,numtype2 b);
        int ss()        //类模板中可以有具体的类型名。利用虚拟类型名只是会在传递具体参数类型时，用具体参数类型替换虚拟类型。
        {
            return hour*minute;
        }
        void dispaly();
        private:
        numtype1 hour;
        numtype2 minute;
    }；
    template<class numtype1,class numtype2>
    void Time<numtype1,numtype2>::diaplay()
    {
        cout<<hour<<minute;  //在类模板体外定义成员函数时需要把template虚拟参数表再写一遍，并加上类名<虚拟类型参数表>
    }
    int main()
    {
        Time<int,flaot> tim1(10,20); //用类模板定义对象。
    }
```

### 对象指针

#### 指向对象的指针:

对象空间的起始地址就是对象的指针。

```c++
 Time *p;Time tim1;p=&tim1;             可以用(*p).hour;p->hour;p->display();访问对象的公有成员
     
对象的动态建立与释放：
     用类名 *指针变量名=new 类名(初始化参数) //创建并初始化匿名对象，如Time *p=new Time(10,20);
     delete p;                    //撤销p指向的内存单元，在释放匿名对象的内存单元之前，会自动调用析构函数，完成有关善后清理工作
```

#### 指向对象成员的指针：

指向对象公用数据成员的指针：

```c++
int *p=&tim1.hour;  //对象公用数据成员与普通变量类似
```

指向对象公用成员函数的指针：

```c++
形式为： 返回值类型 (类名::*指针变量名)(参数列表)，如int (Time::*p)(int ,int);
使指针变量指向公用成员函数形式为： 指针变量名=&类名::成员函数名，如p=&Time::display,不用加()，注意函数的入口地址为&类名::成员函数名，而不是对象名.成员函数名
调用公用函数：对象名.*指针变量名，如tim1.*p(5，10),*p与函数名等价，与普通函数不一样
```

#### this指针

this指针是指向类对象的指针，它的值是当前被调用的成员函数所在对象的起始地址。在程序中用对象名.成员函数调用成员函数时，会将对象的起始地址传递给this指针，this指针是隐式使用的，它会被作为参数被传递给成员函数这样成员函数就可以通过this指针确定它要去调用的是哪一个对象的数据成员。

```c++
如成员函数的定义为void display()
{
    cout<<hour<<minute<<endl;
}
实际上为void display(Time *this)
{
    cout<<this->hour<<this->minute<<endl;//即cout<<(*this).hour<<(*this).minute<<endl;
}
调用tim1.display()实际上为tim1.display(&tim1);
```

### 共有数据的保护

对对象的数据成员的修改做一定的限制，用于保护对象的数据成员。

#### 常对象

```c++
Time const tim1(10,20)//建立常对象时必须赋初值，在对象的生命周期中，对象的所有数据成员的值都不能被修改
    如果一个对象被声明为常对象，则在程序中通过该对象只能调用其常成员函数(但不能修改数据成员的值)，而不能调用其非常成员函数
    对于必须变化的特殊数据成员，可以用mutable来声明，如mutable int count,则可以用常成员函数来修改其值。
```

#### 常数据成员

const int hour;//用const声明某些数据成员，保证其值不会被改变，但既可以用非const也可以用const成员函数访问它

注意：只能通过构造函数的参数化列表对常数据成员进行初始化，如Time::Time(int h):hour(h){}，而不能用带普通的构造函数或其他成员函数对其初始化，因为任何声明为const的变量在建立后都不能再被赋值。常对象相对于所有数据成员都被声明为const的的对象，因此常对象只能用参数初始化列表进行初始化。

#### 常成员函数

void Time::get_time() const;    //常成员函数，不能修改任何数据成员的值，但既可以引用const数据成员，也可以引用非const数据成员
常成员函数不能调用另一个非const成员函数。

小结：无论数据成员或者成员函数有没有用const声明，成员函数都可以调用任何数据成员。

#### 指向对象的常指针

```c++
形式：类名 *const 指针变量名；如Time *const p=&tim1;指针变量的指向不能改变，即指针变量的值不变，但可以通过其改变指向的对象的值。
```

#### 指向常对象的指针

```c++
形式：const 类名 *指针变量名；如const Time *p=&tim1;
无法通过指针变量来修改其指向的对象的值，但指针变量的指向可以改变，且对象可以通过其他方式改变。
```

重要：指向常对象的指针变量可以指向const对象，也可以指向非const对象(但仍不能通过指向常对象的指针变量来修改它)；如果一个对象被声明为const对象，则只能用指向常对象的指针变量指向它，即指向非const对象的指针变量只能指向非const对象，不能指向const对象。

#### 对象的常引用

```c++
void Time::get_time(const Time &tim);在调用过程中不能修改实参的值
```

指向常对象的指针和对象的常引用经常用作函数参数，在调用函数时不会开辟内存建立实参的拷贝，且保证实参在调用过程中不会被改变。

### 静态成员

静态数据成员用于在同一个类的多个对象之间实现数据共享。利用静态数据成员，各对象之间的数据有了沟通的渠道，实现数据共享，这样可以节省空间，提高效率。

```c++
class Time
{
    public:
    void diaplay();
    static int day;	  //将公用数据成员声明成静态数据成员
    static void display();  //声明静态成员函数。
    private:
    static int hour; //将私有数据成员声明成静态数据成员。静态数据成员是属于类的，在所有对象外单独开辟空间，不占用对象的存储空间，所有的对象都可以通过对象名.静态成员数据名来引用静态数据成员，且改变它的值，则在各对象中的值都同时改变了。
    int minute;
};
int Time::hour=10;//静态成员数据只能在类外进行初始化，不能用参数初始化列表对其进行初始化
//静态数据成员在声明类时就会分配空间，即使没定义对象，也可以通过类名::引用，静态数据成员在类的作用域内一直存在，不随对象的建立而分配空间，也不随对象的撤销而释放。
void Time::diaplay()
{
    cout<<day<<hour<<endl;//不能直接引用minute，但可以指定对象来引用，如cout<<tim2.hour;
}
//静态成员函数和非静态成员函数的区别：静态成员函数没有this指针，不能通过默认访问的方式直接引用类中的非静态成员，因为不知道该去找哪个对象。静态成员函数主要用来访问本类的静态数据成员，可以直接引用。
//非静态成员函数既可以引用非静态成员也可以引用静态成员，而静态成员函数只能引用静态成员而不能引用非静态成员。
//用static声明静态数据成员或静态成员函数并影响成员的public与private属性。
int main()
{
    Time tim1;
    tim1.day=1;
    Time::day=1;	//公用的静态数据成员既可以用对象名.引用，也可以用类名::引用
    tim1.diaplay(); //公用的静态成员函数既可以用对象名.引用，也可以用类名::引用
    Time::diaplay();
}
```

### 友员

在类声明中将普通函数，其他类的成员函数或者其他类声明为友员，使不属于本类的函数可以访问本类的私有成员。

面向对象的程序设计的一个基本原则是封装性和信息屏蔽，而友员却可以访问其他类的私有成员，也是对封装原则的一个小小的破坏。但是却能有助于数据共享，提高程序的效率，在实际使用在要在数据共享和信息屏蔽之间找一个恰当的平衡点。

```c++
class Date;   //由于下面Time中出现了Date,需要对其做提前引用声明,只包含类名，不包含类体
class Time
{
    public:
    friend void s1(Time&);    //将普通函数声明为友员函数
    friend void Date::s2(Time&); //将其他类的函数成员声明为友元函数
    friend Display;   //声明友元类。友元类的所有成员函数都是其友元函数。友员的关系是单向的不是双向的，且友员的关系不能传递。
    private:
    int hour;
    int minute;
};
class Date
{
    public:
    void s2(Time&);
    private:
    int year;
    int month;
    int day;
};
void s1(Time&tim1)
{
    cout<<tim1.hour<<tim1.minute<<endl;  //不能直接引用，必须加上对象名
}
void Date::s2(Time&tim1)
{
    cout<<year<<month<<day; //可以直接引用本类在的数据成员
    cout<<tim1.hour<<tim1.minute<<endl;  //不能直接引用其他类的私有数据，必须加上对象名
}
int main()
{
    Time tim1(10,20);
    s1(tim1);
    Date dat1(1,1,1);
    dat1.s2(tim1);
}
```

## 2.运算符重载

运算符重载(operator overloading)是定义一个重载运算符的函数，使指定的运算符不仅能实现原有的功能，还能够实现在函数中指定的新功能。运算符重载的本质是函数的重载。

利用运算符重载，可以让类对象使用现有的运算符而不必重新定义一批新的运算符，扩大了C++已有运算符的使用范围，使程序易于编写、阅读和维护。

运算符重载的一般格式为：

​											函数类型  operator 运算符名(形参表)
​													{对运算符的重载处理} 

C++中绝大部分运算符都允许重载，但是不能重载的运算符有5个：
.(成员访问运算符)	::(域域运算符)	*(成员指针访问运算符)	sizeof(长度运算符)	?:(条件运算符)

重载运算符不改变运算符的运算对象的个数、优先级别、结合性，且不能有默认的参数。重载的运算符必须和用户自定义的结构体类型或类类型一起使用，其参数不能全是C++的标准类型，防止篡改用于标准类型数据的运算符的性质。

```c++
class Complex
{
    public:
    Complex(){real=0;imag=0;}
    Complex(int r,int i){real=r;imag=i;}
    Complex complex_add(Complex &);
    Complex operator +(Complex &);//把运算符重载函数作为类的成员函数
    friend Complex operator +(Complex&c1,complex&c2);//把运算符重载函数作为类的友员函数
    friend Complex operator +(int&num,complex&c2);
    friend Complex operator +(complex&c2,int&num);//对于双目运算符，交换律不适用，需要重载两次
    friend bool operator >(complex&c1,complex&c2);
    
    Complex operator ++();//重载单目运算符，没有参数。为前置单目运算符重载函数。
    Complex operator ++(int);//加一个int表明为后置单目运算符重载函数。
    
    friend ostream& operator <<(ostream&,Complex &);//重载流插入运算符
    friend istream& operator >>(istream&,Complex &);//重载流提取运算符
    
    Complex(int r) {real=r;imag=0;}//转换构造函数。转换构造函数只能有一个参数，参数是需要转换的类型，可以是基本类型，也可以是类，用于将该参数转换为类对象。在程序中可以用类名(指定类型的数据)进行显示强制类型转换。在已定义了相应的转换构造函数情况下，用友员函数重载双目运算符(如+)，可以使交换律可用，如Complex c3=2+c1与Complex c3=2+c1等价，都会将2隐式转换成Complex(2)对象。
    operator int() {return real;}//类型转换函数。类型转换函数的作用是将一个类的对象转换成另一种类型的数据。形式为:operator 类型名(){实现转换的语句，即返回类型为类型名的一个参数}。无函数类型，其返回值类型由指定的类型名确定，只能作为类的成员函数。类型转换函数也称为类型转换运算符重载函数。定义了类型转换函数，则不需要再对各种运算符进行重载，因为类型转换函数可以自动的将类对象转换为基本类型。如int k=c1+2,会隐式的将c1转换为int数据。char c=c1+'a',也会隐式地将c1转换为int数据，再与char类型相加。如同时也定义了重载+的函数，则编译系统不知道怎么解释c1+2，实现二义性。
//转换构造函数和类型转换函数有一个共同的功能：当需要的时候，编译系统会自动调用这些函数，建立一个无名的临时对象或临时变量。   

    private:
    int real;
    int imag;
};
//重载运算符只能把一个运算符用于指定的类，并不是用一个运算符重载函数就可以适用所有的类。
Complex Complex::complex_add(Complex&c2)   //返回一个Complex对象的成员函数
{
    Complex c;
    c.real=real+c2.real;
    c.imag=imag+c2.imag;
    return c;
}
Complex Complex::operator +(Complex &c2)  //定义重载运算符函数。
{
    Complex c;
    c.real=real+c2.real;
    c.iamg=imag+c2.imag;
    return c;
    //以上可以简写为return  Complex(real+c2.real,iamg+c2.iamg);
}
//将运算符重载函数声明为类的成员函数，它可以通过this指针自由地访问本类中的数据，可以少写一个形参。对于双目运算符，要求运算符左侧的操作数必须是一个类对象，且返回值类型必须是本类类型(否则定义这个运算符重载没有意义)。
//而将运算符重载函数作为类的友员函数，是一个普通的函数，可以自由的指定运算符操作数的类型与返回值类型。
Complex operator +(Complex&c1,Complex&c2)
{
    return  Complex(c1.real+c2.real,c1.iamg+c2.iamg)
}
Complex operator +(int&num,Complex&c2)
{
    return  Complex(num+c2.real,c2.iamg);
}
bool operator >(complex&c1,complex&c2)
{
    if(c1.real>c2.real) return true;
    else return false;
}
bool compare(complex&c1,complex&c2)//这是一个普通的函数，只是形参是类对象，但不是类的友元函数，只能访问类对象的公用成员
{
    if(operator >(c1,c2)) return true;   //调用运算符重载函数operator >(c1,c2)
    else return false;
}
Complex Complex::operator ++()
{
    ++real;
    return *this;//先执行操作，再返回当前对象。
}
Complex Complex::operator ++(int)
{
    Complex temp(*this);
    ++real;
    return temp;//先返回当前对象，再对当前对象执行一定的操作。
}
//对象不能直接用<<或>>输入输出，必须进行运算符重载，且只能将运算符重载函数定义为友元函数
ostream& operator <<(ostream& outputname,Complex &c)
{//outputname是ostream类的对象，名字可以随便起
    outputname<<c.real<<c.imag<<endl;
    return outputname;//最后必须返回一个ostream类对象，用于连续插入
}
istream& operator >>(istream& inputname,Complex &c)
{//iutputname是istream类的对象，名字可以随便起
    inputname>>c.real>>c.imag;
    return inputname;//最后必须返回一个istream类对象，用于连续提取
}
int main()
{
    Complex c1(1,2),c2(3,4),c3;
    c3=c1.complex_add(c2);
    c3=c1+c2;//相当于调用c1.operator +(c2);
    c3=2+c1;//相对于调用operator +(2,c1);
    c3=c1+2;//相对于调用operator +(c1,2);
    c3=++c1;//调用前置单目运算符重载函数
    c3=c1++;//调用后置单目运算符重载函数
    cout<<c3<<c2;//调用operator <<(cout,c3),cout传递给outputname，返回一个cout对象。cout是一个ostream类对象。
    //相对于(cout<<c3)<<c2，即cout(新值)<<c2.
    //<<运算符重载函数的第一个参数和函数类型都必须是ostream类型的引用，就是为了返回cout的当前值以便连续输出。
    cin>>c3>>c2;//调用operator >>(cin,c3),cin传递给inputname,返回一个cin对象。cin是一个istream类对象
}
```

默认规则：

1. 赋值运算符=,下标运算符[],函数调用运算符(),成员运算符->必须作为成员函数。
2. 流插入运算符<<和流提取运算符>>，类型转换运算符只能作为友元函数。
3. 一般将单目运算符与复合运算符(+=,++,/,!=,<<=,>>=,^=)作为成员函数。
4. 一般将双目运算(+,-,<,>,==)符作为友员函数。

## 3.继承与派生

面向对象编程强调软件的重用性(software reusability)，C++提供了类的继承机制，解决了软件重用的问题。

一个新类从已有类获得其特性，称为类的继承(inheritance)。从已有类产生一个新类，称为类的派生。
一个派生类只从一个基类继承，称为单继承(single inheritance)；一个派生类有两个或多个基类，称为多重继承(multiple inheritanc)。
派生类是基类的具体化，基类是派生类的抽象。
派生类要继承就会继承基类的全部成员(但不继承基类的构造函数和析构函数，需要在派生类中自己定义)，不能只继承部分成员。

派生类的形式为:

```c++
class 派生类名：[继承方式] 基类名            //可以不写继承方式，默认为私有继承
{
    派生类中新增的成员；
}//派生类中包含三类成员：从基类接收的成员，从基类接收但重写了的成员，新增的成员
```



#### 重写/覆盖与重载：

重写/覆盖：在派生类重新声明一个与基类成员函数同名的函数，且参数的类型与个数都相同，则派生类的函数会覆盖从基类继承来的同名函数，这叫做重写或覆盖。用派生类对象名.函数名()会调用重写后的函数。但被重写的成员函数或数据成员仍然是存在的，可以在派生类中通过基类名::基类成员函数名()或基类名::基类数据成员名显式调用。

重载：函数名相同，而参数的类型与个数至少有一个不同。用派生类对象名.函数名()调用同名函数是会根据实参的类型和个数确定调用的是基类的还是派生类的函数。
(重写可以看出重载的特殊情况)

#### 派生类成员的访问属性

派生类的成员函数可以任意调用派生类的成员(无论是public还是private，private只是限制在类外不能通过对象名.成员名来调用)，基类的成员函数可以任意调用基类的成员，而基类的成员函数不能调用派生类的成员，派生类的成员函数是否可以调用基类的成员需要根据继承方式确定。

| 在基类的访问属性 |      继承方式       | 在派生类在的访问属性 |
| :--------------: | :-----------------: | :------------------: |
|      public      |  public(公用继承)   |        public        |
|     private      |       public        |       不可访问       |
|    protected     |       public        |      protected       |
|      public      |  private(私有继承)  |       private        |
|     private      |       private       |       不可访问       |
|    protected     |       private       |       private        |
|      public      | protected(保护继承) |      protected       |
|     private      |      protected      |       不可访问       |
|    protected     |      protected      |      protected       |

不可访问指的是在派生类中不能直接访问基类的私有成员，但可以通过调用派生类中可以调用的基类成员函数来间接调用甚至修改私有数据成员。无论哪一种继承方式，在派生类中都不能访问基类的私有成员。
protected指的是受保护的成员不能在类外通过对象名.成员名被显式调用，但可以在类中被成员函数任意调用。

#### 派生类的构造函数和析构函数

基类的构造函数和析构函数不能继承，但可以被调用，需要重新定义派生类的构造函数和析构函数。一般会在执行派生类的构造函数时调用基类的构造函数，使派生类的数据成员和从基类继承的数据成员同时被初始化。

建立一个派生类对象时，派生类的构造函数先调用基类构造函数对继承来的数据成员进行初始化，在对其子对象进行初始化，再执行派生类构造函数本身的函数体。
在派生类对象释放时，派生类的析构函数会调用基类的构造函数，先执行派生类的析构函数，在执行子对象的析构函数，再执行其基类的析构函数。

```c++
class Stu
{
    public:
    Stu(int n,string nam,char s)
    {
        num=n;
        name=nam;
        sex=s;
    }
    ~Stu(){};
    protected://private数据成员不能被派生类初始化
    int num;
    string name;
    char sex;
};

class Stu1: public Stu
{
    public:
    Stu1(int n,string nam,char s,int a,string ad):Stu(n,nam,s)
    {
        age=s;
        addr=ad;
    }
    //可以用参数初始化表，写成Stu1(int n,string nam,char s,int a,string ad):Stu(n,nam,s),age(a),addr(ad){}
    //可以先声明,在类体内只需要写Stu1(int n,string nam,char s,int a,string ad);然后在类体下面定义
     Stu1(int n,string nam,char s):Stu(n,nam,s){} //参数表中只有要送给基类构造函数和子对象的参数，只初始化基类的构造函数和子对象，不对派生类新增成员做任何操作，在实际工作中常见这种做法。
    
  Stu1(int n,string nam,char s,int a,string ad,int nam2,char s2):Stu(n,nam,s),stu1(n,nam2,s2),age(a),addr(ad){}
//参数的顺序和数目可以按需传递，形参和实参是按照名字对应的，一个参数可以同时传递给基类和子对象。
    归纳起来，定义派生类的构造函数的一般形式为：
        派生类构造函数名(总参数表):基类构造函数名(参数表)，子对象名(参数表)
    {派生类中新增数据成员的初始语句}
    
    ~Stu(){};
    protected:
    int age;
    string addr;
    Stu stu1;  //类的数据成员可以是对象，即对象中的对象，称为子对象(subobject)。
    Teacher tea;//子对象可以不是基类类型的。这称为类的组合(composition)。
    //通过组合建立了数据类与组合类(或称复合类)的关系，它们之间不是“是”的关系，而是"有"的关系。继承是纵向的，组合是横向的。通过这种方式，可以有效地组合和利用现有的类，减少了代码工作量。
};
class Stu2: public Stu1   //多层派生
{
    public:
    Stu2(int n,string nam,char s,int a,string ad,int w):Stu1(n,nam,s,a,ad),wage(w){}
    //多层派生时，只需要在派生类的构造函数调用其直接基类的构造函数即可，不能一直往上。
    private:
    int wage;
};

//多重继承
class D:public B,private C      //B,C继承自A
{
    public:
    派生类构造函数名(总参数表):基类B构造函数(参数表)，基类C构造函数(参数表)
    {       //多重派生类的构造函数
        派生类中新增的数据成员的初始化语句
    }
/*多重派生的二义性问题：
由于多重继承，可能导致D中有一些重名的成员，这些数据成员不会相互抵消而都会占用派生类对象的存储空间，引用这些重名成员时会产生二义性问题(ambiguous)。
解决方法是显式指定数据成员所属的类，在派生类内用基类名::数据成员名调用(如C::c)，在派生类体外通过派生类对象名.基类名::数据成员名(如d.B::b)调用。
注意：派生类的数据成员只包括基类的数据成员和自己新增的数据成员，不包括基类的基类的数据成员，即基类的基类的数据成员不会占用派生类的空间，因为基类的基类的成员都已经被基类继承，派生类中不可以出现基类的基类名，如在派生类中不可以这样A::a。但如果D直接继承了A(如class D:public B,private C,private A)，则可以用A::a。

虚基类(virtual base class)：
如D继承B和C，二B和C都继承自A，则A的成员会在D中保留两份。会造成二义性，且占用一些不必要的空间。
虚基类使得当基类通过多条派生路径被派生到一个派生类继承时，该派生类只继承该基类一次，也就是说在继承间接共同基类时只保留一份成员。
class A
{};
class B:virtual public A  //虚基类不是在声明基类的时候声明的，而是在声明间接派生类时声明的，因为一个基类可以可以在声明一个派生类时作为虚基类，也可以在声明另一个派生类时不作为虚基类。
{};
class C:viitual private A
{};
class D:public B,private C,protected A
{
	public:
	D(总参数表):A(参数表)，B(参数表)，C参数表)  
	{D中新增的数据成员的初始化语句}
	//在最后的派生类中，不仅要对其直接基类进行初始化，还需要对虚基类初始化。C++编译系统只执行最后的派生类对虚基类构造函数的调用，二忽略基类的其他派生类(如B和C)对虚基类的构造函数的调用，也就保证了虚基类的数据成员不会被多次初始化。
};
//不提倡在程序中使用多重继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多重继承，如能用单一继承解决的问题就不要使用多重继承。也是这个原因，有些面向对象的程序设计语言(如JAVA,Smalltalk)并不支持多重继承。
*/
};
```

#### 派生类和基类的转换

派生类对象可以给基类对象赋值：如Stu stu=stu1;但子对象不能给基类对象赋值。同一个基类的不同派生类之间也不能相互赋值。
派生类对象可以替代基类的对象给基类对象的引用进行赋值或初始化。
如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象。
即基类和派生类之间的赋值只能是多到少，即派生类->基类，将派生类中继承而来的数据成员复制给基类对象的对应的数据成员。

派生类对象的地址可以赋给指向基类对象的指针变量，也就是说，指向基类对象的指针变量可以指向派生类对象。
但需要注意：通过指向基类对象的指针，只能访问派生类中的基类成员，不能访问派生类中增加的成员。调用派生类中的被重写的同名函数时，如p->dispaly()，实际上调用的是基类的成员函数。调用派生类中的新增的成员函数则是非法的。

#### 继承的意义

继承解决了软件重用的问题。

在实际工作中，类库中的声明放在头文件中，而基类的定义放在源文件中，对基类进行编译得到目标文件，然后与头文件一起提供给用户使用，用户可以根据自己的需要去继承基类。由于不提供基类的源码，基类的安全性的得到保证，且基类是单独编译的，在程序中每次编译只需要对派生类进行编译，大大提高了调试程序的效率。如果在必要时修改了基类，只要基类的公用接口不变，派生类不必做代码修改，但基类和派生类都需要重新编译。

实际上，许多基类并不是从已有程序中选取出来的，没有独立的功能，而是专门作为基类设计的，只是一个框架，或者说抽象类。人们根据需要设计一批能适用于不同用途的通用基类，目的是建立通用的数据结构，以便用户能在此基础上添加各种功能建立各种功能的派生类。

## 4.多态性与虚函数

#### 多态性的概念

在面向对象的程序设计中多态(polymorphism)是：向不同对象发送同一个消息，不同的对象在接收时产生不同的行为。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。
在C++中，多态表现为：具有不同功能的函数可以使用同一个函数名，这样就可以实现用一个函数名调用不同内容的函数。

从系统角度看，多态性分为静态多态和动态多态：
**静态多态：**通过函数的重载实现，包括函数的重载和运算符的重载。静态多态要求在程序编译时就知道调用函数的全部信息，在编译时系统就能决定要具体调用的是哪一个函数。静态多态性又称为编译时的多态性。静态多态性的函数调用速度快，效率高，但缺乏灵活性，在程序运行前就已经决定了执行的过程。
(虽然派生类中可以重载或者重写基类的成员函数，但是其也属于静态多态，在编译时会确定具体调用的是哪一个类的成员函数)
(函数重载处理的是同一层次上的同名函数的问题，而虚函数处理的是不同派生层次上的同名函数的问题，前者是横向重载，后者是纵向重载)

**动态多态：**不在编译时确定要调用的是哪个函数，而是在程序运行过程中才动态的确定操作所针对的对象。又称为运行时的多态性。动态多态是通过虚函数实现的，虚函数的作用是允许在派生类中重写与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。通过虚函数可以实现同一个类族中的不同的类对象，对同一函数调用做出不同的响应。当一个类带有虚函数时，编译系统会为该类构造一个虚函数表(virtual function table，简称vtable)，它是一个指针数组，存放每个虚函数的入口地址。这会耗费一定的时间和空间，但系统在进行动态关联时的时间开销是很少的，因此多态性是高效的。
(重载不需要多态，重写才需要多态。因为重载根据实参可以判断调用的函数。)

虚基类的使用方法:

1. 在基类中用virtual声明成员函数为虚函数，在类外定义虚函数时，不必再加virtual
2. 在派生类中重写此函数，函数名、函数类型、函数参数个数和类型都必须与基类的虚函数相同，根据需要重新定义函数体。
   当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数，在派生类声明同名虚函数时可以不加virtual
3. 定义一个指向基类对象的指针变量，并使它指向同一类族在需要调用该函数的对象
4. 通过该指针调用此虚函数，此时调用的就是指针变量所指向的对象中的同名函数。

**静态关联与动态关联**：

确定调用的具体对象的过程称为关联(binding)，也称为联编。函数重载和通过对象名调用虚函数，在编译时即可确定调用的虚函数属于哪一个类，其过程称为静态关联(static binding)，由于是在运行前进行关联的，又称为早期关联(early binding)。
而对于使用虚函数与基类指针结合的方式调用虚函数，编译系统在编译运行时无法确定调用哪一个类对象的虚函数。因为编译只做静态的语法检查，光从p->display()语句是无法确定调用对象的。这种称为动态关联(dynamic binding)，动态关联是在编译以后的运行阶段进行的，也称为滞后关联(late binding)。

**什么时候考虑把一个成员函数声明为虚函数呢？**

首先看成员函数所在的类是否会作为基类，然后看成员函数在类继承后会不会被更改功能，如果希望更改函数功能，应该把其声明为虚函数。

```c++
class Point
{
    public:
    Point(){}
    virtual ~Point(){cout<<"executing Point destructor";}
//如果基类析构函数不声明为virtual,则基类指针p指向派生类对象后用delete p只会指向基类的析构函数，不会指向派生类的析构函数，无法完成对派生类对象的清理工作。故一般将析构函数声明为虚析构函数，这样delete p可以调用派生类和基类的析构函数。将基类的析构函数声明为虚函数后，由该基类派生的所有派生类的析构函数也都自动成为虚函数，即使各派生类的析构函数的名字与基类析构函数名字不同。
//构造函数不能声明为虚函数，因为在建立对象执行构造函数时，对象还没有建立完成，当然谈不上把该对象和函数绑定。对象没有建立完成就不知道调用哪一个对象的虚函数，就不能执行虚函数，从而不能建立对象，这是一个死结。
    
    virtual void display()   //声明虚函数
    {
        cout<<x<<y;
    }
    
    virtual double area() const=0;//声明纯虚函数(pure virtual function)
  
    protected:
    int x;
    int y;    
};
class Circle:public Point
{
    public:
    Circle(){}
    ~Circle(){cout<<"executing Circle destructor";}
    virtual void display()  //在派生类中可以不写virtual,但为了便有阅读，一般要写上
    {
        cout<<x<<y<<r;
    }
    
     virtual double area()
    {return pi*r*r;}
    protected:
    int r;  
};
```

 **纯虚函数**：有时在基类中将某个成员函数定义为虚函数，并不是基类的要求，而是考虑派生类的需要，便于为不同派生类定义不同的虚函数，会在基类预留一个函数名，函数体为空，不执行任何操作，具体功能留给派生类根据需要去定义。这时候可以把该函数声明为纯虚函数，形式为virtual 函数类型 函数名(参数列表)=0;。如果在基类中没有保留函数的名字，而是在各派生类中各自定义，则无法实现多态性。如果在一个类中声明了纯虚函数，且在派生类中没有对该函数进行定义，则该函数在派生类中仍为纯虚函数。

**抽象类**：在面向对象设计中，往往有一些类不是用来生成对象的，而是用来作为基类去建立派生类。这种类叫做抽象类(abstract class)，由于它常作为基类，通常也称为抽象基类(abstract base class)。凡是包含纯虚函数的类都是抽象类。纯虚函数是不能被调用的(但虚函数可以被调用)，包含纯虚函数的类是无法建立对象的。抽象类的作用是作为一个类族的共同基类，为一个类族提供一个公共接口。抽象类体现了类族中各类的共性，把各类中共有的成员函数集中在抽象基类在声明。
如果在抽象类所派生出的新类中对基类的所有纯虚函数都进行了定义，那么这个派生类就不再是抽象类，而成为具体类(concrete class)，可以用来定义对象。但如果派生类没有对基类的所有纯虚函数都进行定义，那么该派生类还是抽象类。

虽然抽象类不能定义对象(或者说抽象类不能实例化)，但是可以定义指向抽象类的指针变量，当派生类成为具体类之后，就可以用这个指针调用派生类的虚函数，实现多态性。所以在实际工作中，往往一个派生类的顶部是一个抽象类，甚至顶部有好几层都是抽象类。

**虚函数和多态性的好处：**使用虚函数提高了程序的可扩充性。
由于在调用虚函数时是在运行阶段才确定调用的是哪一个函数，因此有可能在程序中已经写了虚函数的使用语句，但该函数所在的类还未声明呢。这是可以的，正常的，只需要在运行前把该类声明好，在运行时能保证动态关联即可。

利用虚函数，可以把类的声明和类的使用分离。这对开发商尤为重要，软件开发商只需要向用户提供类的接口(类所在的声明文件和类成员函数定义的目标文件的路径和文件名)，以及使用接口，不必提供类的源码。

利用虚函数和多态性，程序员的注意力集中在处理普遍性，而让执行环境处理特殊性。

## 5.其他

### 1.输入输出流

输入输出是针对内存而言的，数据在内存中都是二进制形式。

输入输出流指有若干字节构成的字节序列从一个对象流到另一个对象。在内存中为每一个数据流开辟内存缓冲区，用来存放流中的数据，流是与内存缓冲区相对应的，缓存区的数据就是流。
在C++中，输入输出通过I/O类库实现。输入输出流被定义为类。C++的I/O库中的类称为流类(stream class)，用流类定义的对象称为流对象。

C++的输入输出包含三个方面：

1. 对系统指定的标准设备的输入输出。即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准输入输出，简称标准I/O。
2. 以外存(磁盘，U盘，光盘)为对象进行输入输出。称为文件的输入输出，简称文件I/O。
3. 对内存中指定的空间进行输入输出。通常指定一个字符数组作为存储空间。称为字符串的输入输出，简称串I/O。

相对于C，C是用printf和scanf库函数来进行输入输出，如printf("%d",i)，scanf("%f",&j)，编译系统不会对数据类型的合法性进行检查，是类型不安全的。而C++的输入输出中，编译系统会对数据类型进行严格的检查，是类型安全的。且C++的I/O类库是可扩展的，可以通过修改和扩充，能用于用户自己定义的类对象的输入输出。

![IO类库继承关系图](D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\IO类库继承关系图.jpg)

isream类中重载了>>，使istream对象能输入各种基本类型的数据，但如果向输入自己定义的数据类型，需要再对>>进行重载。ostream类重载了<<。istream_withassigin和ostream_withassigin类中对=进行了重载。
cin是istream_withassigin类类型的对象，cout是ostream_withassigin类类型的对象

与流类库有关的头文件:
iostream：包含了对输入输出流进行操作所需的基本信息。定义了(即建立)了cin,cout,cerr,clog类对象。
fstream：用于用户管理文件的I/O操作，同时包含了iostream
strstream：用于字符串流I/O，同时包含了iostream
stdiostream：用于混合C和C++的I/O机制时，例如想将C程序转变为C++程序
iomanip：格式化I/O

#### 标准输出流

标准输出流是流向标准输出设备(显示器)的流，iostream头文件中定义了cout,cerr,clog三个输出流对象，cin一个输入流对象。

cerr流对象是标准错误流。cout流通常是传说到显示器输出，但也可以被重定向输出到磁盘文件，而cerr流中的信息只能在显示器输出。

clog流对象也是标准错误流，是console log的缩写，与cerr一样都是在终端显示器上显式出错信息。区别是：cerr不经过缓冲区直接向显示器输出信息，而clog的信息存放在缓冲区，缓冲区满后或遇endl时才向显示器输出。

可以cout<<'a'；可以用流对象的成员函数put输出字符。如cout.put('a')；也可以用C语言的putchar('a')函数输出字符。

#### 标准输入流

cin是输入流对象，它从标准输入设备(键盘)获取数据，程序中的变量通过流提取运算符>>从流中提取数据，但会跳过输入流中的空格，Tab键，换行符和空白字符，即这些不能通过cin>>读取。

只有在键盘输入完数据并按Enter键后，该行的数据才能被送入键盘缓冲区，形成输入流，提取运算符>>才能从中提取数据。

遇到无效字符或文件结束符，无法正常提取数据，cin会出错，值变为0，可以通过测试cin的值，判断流对象是否还处于正常状态和提取操作是否成功。

```c++
if(!cin) //读取出错
    cerr<<"error!";

用get成员函数读入一个字符
    cin.get();//无参的get函数，函数的返回值是读取的字符，若遇到输入流中的文件结束符，则返回返回EOF(符号常量,值为-1)
while((c=cin.get())!=EOF)
    cout.put(c);

    cin.get(ch);//有一个参数的get函数，从输入流中读取一个字符赋给ch，若读取成功则返回非0值，若读取失败(遇到文件结束符)则返回0。

	cin.get(字符数组名或字符指针，字符个数，终止字符);//带三个参数的get函数,从输入流中读取n-1个字符赋给指定的字符数组或字符指针指向的数组，若读取n-1个字符遇到终止字符则提前结束读取。读取成功，返回非0值，读取失败(遇文件结束符)则返回0，提前结束不算失败。遇到终止字符后，不会越过终止字符，终止字符还留在输入流中。

	cin.getline(字符数组名或字符指针，字符个数，终止字符);与cin.get(字符数组名或字符指针，字符个数，终止字符)区别在于遇到终止字符后，会越过终止字符。
        
        eof(是end of file的缩写)函数，如果输入流到达文件末尾(遇到文件结束符)，eof函数值为非零值,否则为0。常用于判断是否读完了文件以结束读取。
        如读入一行字符，将其中的非空格字符输出：
        while(!cin.eof())
            if((cin.get(c))!=' ')
                cin.put(c);

	char c=cin.peek();//返回指针指向的当前字符，但它只是观测，指针并不后移，还停留在当前位置。如果输入流到达文件末尾(遇到文件结束符)，返回EOF(-1).
	
	cin.putback(ch);//将ch插入(而不是替代)到输入流的当前指针位置，以供后面读取
	
	cin.ignore(n,终止字符);//跳过输入流中的n个字符，即后移指针，在遇到指定终止字符提前结束
	cin.ignore();//不带参数，n默认为1，终止字符默认为EOF
//get,getline,eof,peek,putback,ignore是istream类的成员函数，put是ostream类的成员函数	
```

#### 文件输入输出流

文件指存储在外部介质上的数据的集合，系统是以文件为单位进行管理的。

根据文件中数据的组织形式，文件可分为**ASCII文件和二进制文件**。
ASCII文件：又称文本(txt)文件，它的每一个字节存放一个字符的ASCII编码。(输入时会先在内存中的流缓冲区将各类型数据转换为一个个ASCII码，输入时先将ASCII传到内存缓冲区，在用>>提取相应类型的数据时会将对应多个ASCII码拼装组成一个二进制形式的数据)。

二进制文件：又称内部格式文件或字节文件，是把内存中的数据按其在内存中的存储形式原样输出到磁盘上存放。并不知道文件中的各字节之间的连接关系，所以不知道各字节代表的实际数据是什么。

对于字符信息，无论用ASCII形式保存还是二进制形式保存，其数据形式都是一样的；但是对于数值数据，二者是不同的，按ASCII码形式输出需要把内存中的数值先表示为一个字符串再将各个字符的ASCII码输出，而按二进制输出则直接将数值原样输出。用ASCII码形式输出的数据是与字符一一对应的，一个字节代表一个字符，可以直接在屏幕上显示或者打印出来。这种方式使用方便，比较直观，便于阅读，便于对字符逐个进行输入输出。但一般占的存储空间比较多，而且内存中的二进制数据转换为ASCII码需要花费转换时间；用二进制格式输出数值，可以节省外部空间，而且不需要转换时间，但一个字节并不代表一个字符，不能直接显示文件中的内容。如果在程序运行过程中，有些中间结果数据暂时保存在磁盘文件中，以后又需要输入到内存中这时用二进制文件保存是合理的。但如果是为了能显示和打印以供阅读，则应按ASCII码形式输出。二进制输入输出通常用来在内存和设备之间传输一批字节，这种输入输出速度快，效率高，适合大文件的传输。

文件流本身不是文件，而是以文件为输入输出对象的流。
有三个主要的文件输入输出流类:

1. ifstream类，它是从istream类和fstreambase派生的，用来支持从磁盘文件的输入，支持>>
2. ofstream类，它是从ostream和fstreambase类派生的，用来支持从磁盘文件的输出，支持<<
3. fstream类，它是从iostream类和fstreambase派生的，用来支持对磁盘文件的输入输出，支持>>和<<.
   以上三个类都在fstream头文件中声明。由于文件流类都重载了<<，>>，故对ASCII文件也可以用<<，>>，但二进制文件不可以。

##### 文件的打开和关闭

在对文件进行读写操作之前，先要打开文件。打开文件有以下两个目的：

- 通过指定文件名，建立起文件和文件流对象的关联，以后要对文件进行操作时，就可以通过与之关联的**流对象**来进行。
- 指明文件的使用方式。使用方式有只读、只写、既读又写、在文件末尾添加数据、以文本方式使用、以二进制方式使用等多种。

打开文件可以通过以下两种方式进行：

- 调用流对象的 open 成员函数打开文件。
- 定义文件流对象时，通过构造函数打开文件。

先看第一种文件打开方式。以 ifstream 类为例，该类有一个 open 成员函数，其他两个文件流类也有同样的 open 成员函数：

```c++
void open(const char* szFileName, int mode)
第一个参数是指向文件名的指针(即"文件名"代表文件的地址)，第二个参数是文件的打开模式标记。
    对象名.open("c:\\tmp\\f1.dat",ios::out); //注意\\代表\,或者写成r"c:\tmp\f1.dat"
```

第二种打开方式。在声明流类时定义了带参数的构造函数，其中包含了打开磁盘文件的功能，因此在定义流对象时可以在构造函数中给出文件名和打开模式也可以打开文件。以 ifstream 类为例，它有如下构造函数：

```c++
ifstream::ifstream (const char* szFileName, int mode = ios::in, int);
第一个参数是指向文件名的指针；第二个参数是打开文件的模式标记，默认值为ios::in; 第三个参数是整型的，也有默认值，一般极少使用。
    如istream infile("f1.dat",ios::in)
```

输入输出方式是在ios类中定义的枚举常量，如下表：

![文件输入输出方式设置值](D:\My_Program_data\Cpp-exercise\Cpp_基础知识整理归纳\文件输入输出方式设置值.png)

文件的打开模式标记代表了文件的使用方式，这些标记可以单独使用，也可以组合使用。如ios::in|ios::out|ios::binary，打开一个二进制文件，可读可写。

```c++
如果打开文件失败，open的返回值为0，流对象的值为0，可以据此来判断文件打开是否成功:
if(!outfile.open("f1",ios::out))  //或if(!outfile)
    cerr<<"open error";
```

在对已打开的文件读写完成后，应当及时关闭该文件。所谓关闭，即是解除文件与文件流对象的关联，原来设置的工作方式也失效。此时可以将文件类对象与其他文件建立关联，对新的文件进行操作。

```c
outfile.close();  //不需要任何参数
```

每打开一个文件都有一个文件指针(文件读写位置标记)，每次读写都从文件指针的当前位置开始，该指针的初始文件有I/O系统方式指定。每读入一个字节，指针就会向后移动一个一位。当指针到达文件末尾，此时流对象的成员函数eof的值为非0(一般设为1).
与文件位置标记有关的成员函数：

|        成员函数         |                       作用                       |
| :---------------------: | :----------------------------------------------: |
|        gcount()         |          得到最后一次输入所读入的字节数          |
|         tellg()         |          得到输入文件位置标记的当前位置          |
|         tellp()         |          得到输出文件位置标记的当前位置          |
|   seekg(文件中的位置)   | 将输入文件的位置标记移到指定的位置(以开头为参照) |
| seekg(位移量，参照位置) |           以参照位置为基础移动若干字节           |
|   seekp(文件中的位置)   | 将输入文件的位置标记移到指定的位置(以开头为参照) |
| seekp(位移量，参照位置) |           以参照位置为基础移动若干字节           |

其中:g表示get，代表输入；p表示put，代表输出。文件中的位置和位移量被指定为long型整数，以字节为单位。
参照位置包含：ios::beg：文件开头位置	ios::cur:位置标记当前位置	ios::end：文件末尾	//它们都是在ios类中定义的枚举常量
如，infile(-50,ios::cur)，输入文件的位置标记从当前位置后移50个字节。 //负数代表后移，往文件开头移动，正数代表前移，往文件末尾移动

##### 对ASCII文件操作：

既可以用<<，>>，也可以用成员函数put,get,getline进行字符的输入输出

```c
//从键盘读入一行数据，把其中的字符依次存放在文件f1.txt中，再把它从该文件读入程序，将其中的小写字母改为大写字母，再存入f2.txt中。
#include<fstream>
#include<iostream> //有的编译系统在fstream中声明了iostream，就不需要这行
using namespace std;
void save_to_file(char *filename)
{
	ofstream outfile(filename, ios::out);
	if (!outfile)
	{
		cerr << "open file error"; exit(1);//exit是系统函数，参数可以是任意整数，与abort()等价。
	}
	char c[80];
	cin.getline(c, 80);
	for(int i=0;c[i]!=0;i++)
		if (c[i] >= 65 && c[i] <= 90 || c[i] >= 97 && c[i] <= 122)
		{
			//outfile.put(c[i]);   //将字符写入文件
			outfile << c[i];       //可以直接用"输出文件流对象名<<数据"进行输出,但对ASCII文件每次只能输入输出一个字符
			cout << c[i];
		}
	cout << endl;
	outfile.close();
}
void get_from_file(char *filename1, char *filename2)
{
	ifstream infile(filename1, ios::in);
	if (!infile)
	{
		cerr << "open file error"; exit(1);
	}
	ofstream outfile(filename2, ios::out);
	if (!outfile)
	{
		cerr << "open file error"; exit(1);
	}
	char c;
	while (infile>>c)    //读取成功则执行下面复合语句
		//可以用infile.get(c)
	{
		if (c >= 97 && c <= 122)
			c = c - 32;
		outfile.put(c);
		cout << c;
	}
	cout << endl;
	outfile.close();
	infile.close();
}
int main()
{
	save_to_file(R"(C:\Users\d\Desktop\temp.txt)");
	get_from_file(R"(C:\Users\d\Desktop\temp.txt)", R"(C:\Users\d\Desktop\temp2.txt)");
	return 0;
}
```

##### 对二进制文件的操作

打开二进制文件时必须指定ios::binary。而ASCII文件相比，ASCII不能同时输入输出，而二进制文件是既能输入又能输出的文件。
对ASCII文件一般每次只读写一个字符，而二进制文件可以指定每次要读写的字节长度。ASCII文件读取是和一个变量联系的，而二进制文件读取适合一个指针联系的，可以用指针指定要读写的内存位置。

对二进制文件的读写主要用istream类的成员函数read和ostream的成员函数write来实现。这两种函数的原型为：

```c
istream& read(char *buffer,int len);//在输入时，指针指向的内存数据会被改变
ostream& write(const char *buffer,int len);//在输出时，不允许改变指针指向的内存中的数据
buffer指向内存中的一段存储空间，len是读取的字节数。
    调用方式为:
a.write(p1,50);//将p1指向的内存单元开始的50个字节的内存数据不加转换地写到a中。
b.read(p2,50);//从文件当前读写位置开始读取50个字节存放到p1指向的内存单元(或遇EOF结束)。
二进制文件不用<<,>>
```

```c
//用二进制文件处理5个学生的数据
#include<fstream>
#include<iostream> //有的编译系统在fstream中声明了iostream，就不需要这行
using namespace std;
struct Stu
{
	int num;
	char name[20];
	float score;
};
void dosomething(char *filename1,char *filename2,Stu stus[])
{
	fstream iofile(filename1, ios::out|ios::in|ios::binary);
	//用fstream定义输入输出二进制文件流对象
	if (!iofile)
	{
		cerr << "open file error"; abort();
	}
	for (int i = 0; i < 5; i++)
		iofile.write((char*)&stus[i], sizeof(stus[i]));
    //iofile.write((char*)&stus[0], 5 * sizeof(stus[0]));可以一次性全部输出，但是不能用sizeof(stus)数组名。
	Stu stus2[5];
	for (int i = 0; i < 5; i=i + 2)
	{
		iofile.seekg(i * sizeof(stus[i]), ios::beg);
		iofile.read((char*)&stus2[i/2], sizeof(stus[0]));//把第1，3，5学生的数据读出来
		cout << stus2[i/2].num << stus2[i/2].name << stus2[i/2].score << endl;
	}
	ofstream outfile(filename2, ios::out | ios::binary);
	if (!outfile)
	{
		cerr << "error"; abort();
	}
	for (int i = 0; i < 3; i++)   //将1，3，5学生写入文件2
	{
		outfile.write((char*)&stus2[i], sizeof(stus2[i]));
	}
	strcpy_s(stus[2].name, "Cuiyugui");   //strcpy的安全版本
	stus[2].score = 1000;
	iofile.seekp(2 * sizeof(stus[2]), ios::beg);
	iofile.write((char*)&stus[2], sizeof(stus2[2]));
	iofile.seekg(0, ios::beg);  //重新定位到文件开头
	for (int i = 0; i < 5; i++)
	{
		iofile.read((char*)&stus[i], sizeof(stus[i]));
	    cout << stus[i].num << stus[i].name << stus[i].score << endl;
	}
	iofile.close();
	outfile.close();
}
int main()
{
	Stu stus[5] = {
		1001,"cui",99,1002,"zhang",90,1003,"liu",89,1004,"shu",10,1005,"xiao",78
	};
	dosomething("C:/Users/d/Desktop/a1.dat", "C:/Users/d/Desktop/Untitled-2.dat",stus);
	return 0;
}
```

#### 字符串流

文件串流不是以外存文件为输入输出的对象，而是以内存中用户自定义的字符数组(字符串)为输入输出的对象，也称为内存流。

在字符数组中可以存放字符，也可以存放整数，浮点数等其他类型数据，在向字符数组存入数据之前，要先将内存中的数据从二进制形式转换为ASCII代码，然后存放在缓冲区，待缓冲区满后再从缓冲区送到字符数组。从字符数组读取数据时，先将字符数组中的ASCII数据送到缓冲区，再赋给变量前要先将ASCII代码转换为二进制形式。总之，流缓冲区中的数据格式要和字符数组相同。

字符串流类没有open成员函数，因此要在建立字符串流对象时通过给定参数来确定字符串流与字符数组的关联，具体是通过构造函数类建立关联。且建立关联的字符数组和正常的字符数组一样，可以在内存中随意对之操作。

头文件strstream中包含了三个字符串输入输出流类:ostrstream,istrstream,strstream.可以使用<<,>>。

```c++
建立输出字符串流对象：
ostrstream::ostrstream(char *buffer,int n,int mode=ios::out)
    buffer是指向字符数组首元素的指针，一般是数组名，n是流缓冲区的大小(即能输入输出字符数组的字节数)，一般可以选为与字符数组大小相同，第三个参数是可选的，默认为ios::out模式.
   示例： Stu stus[5] = {
		1001,"cui",99,1002,"zhang",90,1003,"liu",89,1004,"shu",10,1005,"xiao",78}
	ostrstream strout(stus,50);//和字符数组建立关联
	for(int i=0;i<3;i++)
        strout<<stus[i].num<<stus[i].name<<stus[i].score;//直接用<<,>>输入输出
	strout<<ends;
	cout<<stus;

建立输入字符串流对象：
    istrstream::istrstream(char *buffer);//将字符数组中的全部数据都输入
 	istrstream::istrstream(char *buffer,int n);//将字符数组中的前n个字节的数据输入
建立输入输出字符串流对象:
	strstream::strstream(char *buffer,int n,int mode);
	如：strstream strio(stus,sizeof(stus),ios::out|ios::in);
	示例：  istrstream strin(stus,sizeof(stus));
        for(int i=0;i<3;i++)
       		 strin>>stus[i].num>>stus[i].name>>stus[i].score;//会在缓冲区将ASCII转换为对于的二进制赋给相应变量
```

字符串流从字符数组中读取数据就如同从键盘读取数据一样，可以读取字符数据，还可以读取整数，浮点数等其他类型。如果不用字符串流，只能从字符数组逐个访问字符，而不能按其他类型的数据形式读取数组。与字符串流关联的字符数组相对于内存中的临时仓库，可以用来存放各种类型的数据，在需要时再从中读取。它的用法与标准输入输出类型，但标准设备(键盘和显示器)不能保存数据。与外存相比，它不用建立文件(不需要打开和关闭)，存取速度快。但它的生命周期与其所在的函数模块相同，该模块结束后字符数组也就不存在了，因此只能作为临时的存储空间。

### 2.异常处理

程序常见的错误有两大类:**语法错误和运行错误**。
语法错误又称为编译错误，可以在编译阶段发现。而运行错误会在运行过程中出现异常。
在设计程序时，应当事先分析程序运行时可能出现的各种意外的情况，并且分别制定出相应的处理方法，这就是程序的异常处理的任何。所谓异常处理，就是针对运行时出现的错误以及其他例外情况的处理。

C++的异常处理机制是：如果在执行一个函数的过程中出现异常，可以不在本函数中立即处理，而是发出一个信息，传给它的上一级(即调用它的函数)，它的上一级捕获到这个信息后进行处理。如果上一级也无法处理，就再传给上一级，逐级上送，如果到最上一级还无法处理，就会异常终止程序。这样做使得异常的发现和处理不必由同一个函数来完成。好处是使底层的函数专门用于解决实际任务，而不必再承担处理异常的任务，以减轻底层函数的负担。

C++的异常处理机制由3个组成部分：try(检查)，throw(抛出)和catch(捕捉)。

```c++
int main()
{
    void f1();
    try         //把可能出现异常的语句放在try里面
    {f2();}
    catch(int)  //try和catch之间不能有任何语句，有try必须有catch，但catch不接在try下面而放在其他函数中。
//try语句里面发生错误而throw抛出异常后，流程会跳出当前的try语块而去逐级寻找类型匹配的catch，如果当最上一级的catch类型都不匹配的话程序会异常终止。执行完catch语句后不会直接结束程序，而是接着catch语块后面的语句继续执行。
    {
        cout<<"error0";
    }
    cout<<"end!";
    return 0;
}
void f1()
{
    void f2;
    try
    {
        f2();
    }
    catch(double k) 		//可以捕获到抛出的异常信息并将之赋值给形参，便于在下面对异常信息变量进行相应的处理
    {
        cout<<"error2"<<k;
    }
    catch(float)
    {
        cout<<"error float";//一个try后面可以跟多个catch
    }
    catch(long)
    {
        cout<<2;
        throw;//可以继续将异常信息再次抛出
    }
    catch(...)   //可以捕获任意类型的异常信息，一般放在最后
    {
        cout<<"ERROR"<<endl;
    }
}
void f2()
{
    float a=0;
    try
    {
        if(a==0) throw a;//抛出异常，即抛出一个变量
        //throw;  可以不用任何判断条件，直接抛出
    }
}
```

#### 在声明函数时进行异常情况指定

double ff(int a,int b) throw(double);//指定该函数可以抛出的异常信息类型，在声明写了在定义函数时也要写

double ff(int a,int b) throw(double,int,char);//可以指定多种异常信息类型

double ff(int a,int b);//如果没指定，则可以抛出任意类型的异常信息

double ff(int a,int b) throw();//无参数的话，即使在函数执行过程中出现了throw语句，但实际上并不执行throw语句，不抛出任何异常信息，程序直接非正常终止。

#### 在异常处理中处理析构函数

如果在try语块中出现了异常，则try语块中建立的临时类对象都会自动执行析构函数，析构函数执行的顺序与构造的顺序相反，然后再执行与异常信息匹配的catch块中的语句。

### 3.命名空间

命名空间(namespace)是ANSI C++引入的可以由用户命名的作用域，用来处理程序中常见的同名冲突。

在不同文件可能定义了同名的全局变量，类或函数等实体，在用#include包含进来时，会导致重复定义，这就是同名冲突。

所谓命名空间，实际上就是一个由程序设计者命名的内存区域。程序设计者可以根据需要指定一些有名字的空间域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分割开来。

```c++
在head1.h中：
#include <cmath>
namespace//把需要加入命名空间的实体在命名空间中声明或定义。可以包含：变量，常量，函数(可以是声明或者定义),结构体，类，模板，其他命名空间
{            //命名空间中不能包含#include这种预处理指令，否则编译会出错。
    class Stu
    {
        public:
        int n;
    };
    int a;
    void display();
}
在head2.h中：
#include <string>
namespace ns2  //不同命名空间中可以有相同的实体，但同一个命名空间中绝不能包含相同实体
{
    class Stu
    {
        public:
        int n;
    };
    int a;
    void display();
    void pill();
}
namespace//无名的命名空间。与static的功能类似。该空间声明的全部成员都只能在本文件中使用，不能被其他文件调用。
{
    display();
}
在程序文件中:
#include<iostream>
#include<head1.h>
#include<head2.h>
int main()
{
    ns1::display();
    ns2::diaplay();
}
使用命名空间中的实体时，用命名空间名::实体名。
C++提供了一些简化使用命名空间成员的手段
(1)使用命名空间别名
    namespace Television
{
    
}
   namespace TV=Television;
(2)使用using 命名空间成员名
    using ns1::Stu;
using 声明的空间成员名的有效范围从using开始到using所在的作用域结束。
(3)使用using namespace 命名空间名
    using namespace ns1;
可以一次性声明一个命名空间中的全部成员
```

标准C++库的所以的标识符都是在一个名为std的命名空间中定义的，包括标准头文件中的函数，类，对象和类模板等。



# C++泛型编程(generic programing)

## 2.标准模板库STL

STL是C++标准的组成部分，不是面向对象编程，而是一种不同的编程模式——泛型编程。

STL提供一组表示容器/迭代器/函数对象和算法的模板，能够构造各种容器(包括数组/队列/链表等)和执行各种操作(包括搜索/排序和随机排列等)。

容器是一个与数组类似的单元，可以动态的存储若干个类型一样的值。

算法是完成特定任务(如对数组进行排序和在链表中查询特定的值)的处方。

函数对象是类似于函数的对象，可以是类对象或函数指针(包括函数名,因为函数名被用作指针)。

### 模板类vector(矢量)

是一种容器类，可以用来创建动态数组，使用动态内存分配，在使用时要#include <vector>

创建一维动态矢量：vector<int>  Nums(n)，矢量中含有n个int 变量，Nums就是一个对象，Nums[2]表示矢量中的第3个元素。

创建二维动态矢量：vector<vector<int>> Nums，默认为0个元素。Nums\[2][3]，可以像数组一样用[]随机访问元素。

所有的STL容器都提供了一些基本，vector模板类也可以使用，如:

```c++
Nums[2].size()   //返回Nums[2]容器中的元素个数
Nums.size()      //返回Nums容器中总的元素个数
Nums[2].swap(Nums[3])  //交换两个容器的内容
Nums.begin()    //返回一个指向容器第一个元素的迭代器
Nums.end()      //返回一个表示超过容器尾的迭代器
Nums[1].empty()  //若Num[1]为空则返回true
vector<int> NewNums(Nums)  //可以用一个已有的矢量去初始化一个新矢量
Nums.push_back(a) //在矢量末尾插入一个元素
Nums.erase(Nums.begin(),Nums.begin()+2)//删除Nums矢量第一个和第二个元素
Nums.insert(a)//在头部插入一个元素
Nums.insert(Nums.end(),Other.begin()+1,Other.end())//将Other矢量的第2个到最后一个元素插到Nums的末尾
Nums.insert(Nums.begin(),Other.begin(),Other.begin()+2)//将Other矢量的第1个到第2个元素插到Nums的头部
```

#### 迭代器

迭代器是一个广义指针，指向容器，能够用来遍历容器的对象，还可以通过解除引用算符*来引用容器，让STL能够为各种不同的容器类(包括那些简单指针无法处理的类)提供统一的接口。

```
声明迭代器:vector<int>::iterator p;//每一个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为iterator的typedef
for(p=Nums[1].begin();p!=Nums[1].end();p++)
cout<<*p;
```

#### 可对矢量执行的其他操作

STL从更广泛的角度定义了一些非成员函数，可用于操作所有容器类，但并不是容器的成员函数。

```c++
for(p=Nums[1].begin();p!=Nums[1].end();p++)
Show(*p);
等价于：for_each(Nums.begin(),Nums.end(),Show)//前两个是定义容器中区间的迭代器,最后一个是指向函数的指针，即函数对象

Random_shuffle(Nums.begin(),Nums.end())//Random_shuffle函数接受两个指定区间的迭代器参数，并随即排列该区间中的元素
    
sort(Nums.begin(),Nums.end())
//Sort函数可以对容器指定区间的元素进行排序。如果容器元素是用户自定义的对象，需要先对容器元素类型重载运算符<，如果是基类型则不必。
sort(Nums.begin(),Nums.end(),WorseThan)//可以按照WorseThan定义的比较方法对容器中的元素进行排序
```

