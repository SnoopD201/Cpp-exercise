# 排序法总结

![常用排序法总结](D:\My_Program_data\Cpp-exercise\排序法汇总\常用排序法总结.png)

## 比较排序和非比较排序

   常见的排序算法都是比较排序，非比较排序包括计数排序、桶排序和基数排序，非比较排序对数据有要求，因为数据本身包含了定位特征，所有才能不通过比较来确定元素的位置。

   比较排序的时间复杂度通常为O(n2)或者O(nlogn)，比较排序的时间复杂度下界就是O(nlogn)，而非比较排序的时间复杂度可以达到O(n)，但是都需要额外的空间开销。

   比较排序时间复杂度为O(nlogn)的证明：

   a1,a2,a3……an序列的所有排序有n!种，所以满足要求的排序a1',a2',a3'……an'（其中a1'<=a2'<=a3'……<=an'）的概率为1/n!。基于输入元素的比较排序，每一次比较的返回不是0就是1，这恰好可以作为决策树的一个决策将一个事件分成两个分支。比如冒泡排序时通过比较a1和a2两个数的大小可以把序列分成a1,a2……an与a2,a1……an（气泡a2上升一个身位）两种不同的结果，因此比较排序也可以构造决策树。根节点代表原始序列a1,a2,a3……an，所有叶子节点都是这个序列的重排（共有n!个，其中有一个就是我们排序的结果a1',a2',a3'……an'）。如果每次比较的结果都是等概率的话（恰好划分为概率空间相等的两个事件），那么二叉树就是高度平衡的，深度至少是log(n!)。

   又因为 1. n! < n^n^ ,两边取对数就得到log(n!)<nlog(n)，所以log(n!) = O(nlogn).

​               2. n!=n(n-1)(n-2)(n-3)…1 > (n/2)^(n/2) 两边取对数得到 log(n!) > (n/2)log(n/2) = Ω(nlogn)，所以 log(n!) = Ω(nlogn)。

   因此log(n!)的增长速度与 nlogn 相同,即 log(n!)=Θ(nlogn)，这就是通用排序算法的最低时间复杂度O(nlogn)的依据。

## 1.冒泡排序法

是一种交换排序，基本思想为：两两比较相邻记录的关键字，如果反序则交换，直到没有反序记录为止。类似于冒泡，它通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，较小的数据上升。冒泡排序是最慢的排序算法。在实际运用中它是效率最低的算法。

有两种优化思路：

优化一：如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个Flag做标记，默认为false，如果发生交互则置为true，每轮结束时检测Flag，如果为true则继续，如果为false则返回。

优化二：某一轮结束位置为j，但是这一轮的最后一次交换发生在lastSwap的位置，则lastSwap到j之间是排好序的，下一轮的结束点就不必是j--了，而直接到lastSwap即可。

## 2.简单选择排序

遍历数组，遍历到i时，a0,a1...ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。

无论好坏情况，它都需要进行n*(n-1)/2次比较，但是它最大的特点就是交换移动数据次数比较少，最好为0次,最差为(n-1)次，这样节约了交换数据的时间。总的来说，简单选择排序性能略优于冒泡排序。

## 3.直接插入排序

遍历数组，遍历到i时，a0,a1...ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。可见相等元素比较是，原来靠后的还是拍在后边，所以插入排序是稳定的。

当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。

直接插入排序性能比冒泡排序和简单选择排序要稍好一点。

